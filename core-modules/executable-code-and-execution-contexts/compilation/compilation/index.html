<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="./favicon.ico" />
    <link rel="stylesheet" href="/javascript-guidebook/umi.css" />
    <script>
      window.routerBase = "/javascript-guidebook/";
    </script>
    <script>
      //! umi version: 3.2.20
    </script>
    <title>编译阶段</title>
  
</head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;http://img.mrsingsing.com/javascript-guidebook-favicon.png&#x27;)" href="/javascript-guidebook//">JavaScript Guidebook</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><a href="/javascript-guidebook//basic-concept">基本语法</a><a href="/javascript-guidebook//standard-built-in-objects">内置对象</a><a aria-current="page" class="active" href="/javascript-guidebook//core-modules">核心模块</a><a href="/javascript-guidebook//object-oriented-programming">OOP</a><a href="/javascript-guidebook//browser-object-model">BOM</a><a href="/javascript-guidebook//document-object-model">DOM</a><a href="/javascript-guidebook//computer-networks">计算机网络</a><a href="/javascript-guidebook//design-patterns">设计模式</a><a target="_blank" rel="noopener noreferrer" href="https://github.com/tsejx/javascript-guidebook">Github<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;http://img.mrsingsing.com/javascript-guidebook-favicon.png&#x27;)" href="/javascript-guidebook//"></a><h1>JavaScript Guidebook</h1><p>JavaScript 完全知识体系</p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li><a href="/javascript-guidebook//basic-concept">基本语法</a></li><li><a href="/javascript-guidebook//standard-built-in-objects">内置对象</a></li><li><a aria-current="page" class="active" href="/javascript-guidebook//core-modules">核心模块</a></li><li><a href="/javascript-guidebook//object-oriented-programming">OOP</a></li><li><a href="/javascript-guidebook//browser-object-model">BOM</a></li><li><a href="/javascript-guidebook//document-object-model">DOM</a></li><li><a href="/javascript-guidebook//computer-networks">计算机网络</a></li><li><a href="/javascript-guidebook//design-patterns">设计模式</a></li><li><a target="_blank" rel="noopener noreferrer" href="https://github.com/tsejx/javascript-guidebook">Github<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div><ul class="__dumi-default-menu-list"><li><a href="/javascript-guidebook//core-modules">核心模块</a></li><li><a aria-current="page" class="active" href="/javascript-guidebook//core-modules/executable-code-and-execution-contexts/compilation">编译阶段</a><ul><li><a aria-current="page" class="active" href="/javascript-guidebook//core-modules/executable-code-and-execution-contexts/compilation/compilation"><span>编译阶段</span></a></li><li><a href="/javascript-guidebook//core-modules/executable-code-and-execution-contexts/compilation/lexical-scope"><span>词法作用域</span></a></li><li><a href="/javascript-guidebook//core-modules/executable-code-and-execution-contexts/compilation/function-as-scopes"><span>函数作用域</span></a></li><li><a href="/javascript-guidebook//core-modules/executable-code-and-execution-contexts/compilation/blocks-as-scopes"><span>块作用域</span></a></li><li><a href="/javascript-guidebook//core-modules/executable-code-and-execution-contexts/compilation/hoisting"><span>声明提升</span></a></li><li><a href="/javascript-guidebook//core-modules/executable-code-and-execution-contexts/compilation/closures"><span>闭包</span></a></li></ul></li><li><a href="/javascript-guidebook//core-modules/executable-code-and-execution-contexts/execution">执行阶段</a><ul><li><a href="/javascript-guidebook//core-modules/executable-code-and-execution-contexts/execution/execution-context-stack"><span>执行上下文</span></a></li><li><a href="/javascript-guidebook//core-modules/executable-code-and-execution-contexts/execution/variable-object"><span>变量对象</span></a></li><li><a href="/javascript-guidebook//core-modules/executable-code-and-execution-contexts/execution/scope-chain"><span>作用域链</span></a></li><li><a href="/javascript-guidebook//core-modules/executable-code-and-execution-contexts/execution/this"><span>this</span></a></li></ul></li><li><a href="/javascript-guidebook//core-modules/executable-code-and-execution-contexts/memory-management">内存管理</a><ul><li><a href="/javascript-guidebook//core-modules/executable-code-and-execution-contexts/memory-management/memory-model"><span>内存模型</span></a></li><li><a href="/javascript-guidebook//core-modules/executable-code-and-execution-contexts/memory-management/memory-life-cycle"><span>内存生命周期</span></a></li><li><a href="/javascript-guidebook//core-modules/executable-code-and-execution-contexts/memory-management/garbage-collection"><span>垃圾回收</span></a></li></ul></li><li><a href="/javascript-guidebook//core-modules/executable-code-and-execution-contexts/concurrency-model">并发模型</a><ul><li><a href="/javascript-guidebook//core-modules/executable-code-and-execution-contexts/concurrency-model/concurrency-model"><span>并发模型</span></a></li><li><a href="/javascript-guidebook//core-modules/executable-code-and-execution-contexts/concurrency-model/event-loop"><span>事件循环</span></a></li><li><a href="/javascript-guidebook//core-modules/executable-code-and-execution-contexts/concurrency-model/timers-mechanism"><span>定时器机制</span></a></li></ul></li><li><a href="/javascript-guidebook//core-modules/ecmascript-function-objects/function-declarations">函数声明</a><ul><li><a href="/javascript-guidebook//core-modules/ecmascript-function-objects/function-declarations/function-definitions"><span>函数声明定义</span></a></li><li><a href="/javascript-guidebook//core-modules/ecmascript-function-objects/function-declarations/arrow-function-definitions"><span>箭头函数</span></a></li><li><a href="/javascript-guidebook//core-modules/ecmascript-function-objects/function-declarations/async-function-definitions"><span>异步函数</span></a></li></ul></li><li><a href="/javascript-guidebook//core-modules/ecmascript-function-objects/function-arguments">函数参数</a><ul><li><a href="/javascript-guidebook//core-modules/ecmascript-function-objects/function-arguments/function-parameters"><span>函数参数</span></a></li><li><a href="/javascript-guidebook//core-modules/ecmascript-function-objects/function-arguments/default-parameters"><span>默认参数</span></a></li><li><a href="/javascript-guidebook//core-modules/ecmascript-function-objects/function-arguments/rest-parameters"><span>剩余参数</span></a></li></ul></li><li><a href="/javascript-guidebook//core-modules/ecmascript-function-objects/function-calls">函数调用</a><ul><li><a href="/javascript-guidebook//core-modules/ecmascript-function-objects/function-calls/method-invocation-pattern"><span>方法调用模式</span></a></li><li><a href="/javascript-guidebook//core-modules/ecmascript-function-objects/function-calls/function-invocation-pattern"><span>函数调用模式</span></a></li><li><a href="/javascript-guidebook//core-modules/ecmascript-function-objects/function-calls/constructor-invocation-pattern"><span>构造函数调用模式</span></a></li><li><a href="/javascript-guidebook//core-modules/ecmascript-function-objects/function-calls/apply-invocation-pattern"><span>间接调用模式</span></a></li></ul></li><li><a href="/javascript-guidebook//core-modules/ecmascript-function-objects/function-internal">函数内部</a><ul><li><a href="/javascript-guidebook//core-modules/ecmascript-function-objects/function-internal/function-accessor"><span>函数存取器</span></a></li><li><a href="/javascript-guidebook//core-modules/ecmascript-function-objects/function-internal/function-prototype-object-methods"><span>函数原型对象方法</span></a></li><li><a href="/javascript-guidebook//core-modules/ecmascript-function-objects/function-internal/function-prototype-object-properties"><span>函数原型对象属性</span></a></li></ul></li><li><a href="/javascript-guidebook//core-modules/ecmascript-function-objects/function-types">函数类型</a><ul><li><a href="/javascript-guidebook//core-modules/ecmascript-function-objects/function-types/structure-function"><span>构造函数</span></a></li><li><a href="/javascript-guidebook//core-modules/ecmascript-function-objects/function-types/class-structure-function"><span>类构造函数</span></a></li><li><a href="/javascript-guidebook//core-modules/ecmascript-function-objects/function-types/lazy-function"><span>惰性函数</span></a></li><li><a href="/javascript-guidebook//core-modules/ecmascript-function-objects/function-types/cascade-function"><span>级联函数</span></a></li><li><a href="/javascript-guidebook//core-modules/ecmascript-function-objects/function-types/callback-function"><span>回调函数</span></a></li><li><a href="/javascript-guidebook//core-modules/ecmascript-function-objects/function-types/hight-order-function"><span>高阶函数</span></a></li><li><a href="/javascript-guidebook//core-modules/ecmascript-function-objects/function-types/function-currying"><span>函数柯里化</span></a></li><li><a href="/javascript-guidebook//core-modules/ecmascript-function-objects/function-types/throttle"><span>函数节流</span></a></li><li><a href="/javascript-guidebook//core-modules/ecmascript-function-objects/function-types/debounce"><span>函数防抖</span></a></li><li><a href="/javascript-guidebook//core-modules/ecmascript-function-objects/function-types/memorize-function"><span>函数记忆</span></a></li><li><a href="/javascript-guidebook//core-modules/ecmascript-function-objects/function-types/sleep-function"><span>函数睡眠</span></a></li><li><a href="/javascript-guidebook//core-modules/ecmascript-function-objects/function-types/partial-function"><span>偏函数</span></a></li></ul></li><li><a href="/javascript-guidebook//core-modules/modularization">模块化</a><ul><li><a href="/javascript-guidebook//core-modules/modularization/modularization"><span>模块化</span></a></li><li><a href="/javascript-guidebook//core-modules/modularization/import"><span>模块导入 import</span></a></li><li><a href="/javascript-guidebook//core-modules/modularization/export"><span>模块导出 export</span></a></li><li><a href="/javascript-guidebook//core-modules/modularization/compound"><span>模块导入/导出的复合写法</span></a></li><li><a href="/javascript-guidebook//core-modules/modularization/module-inheritance"><span>模块继承</span></a></li><li><a href="/javascript-guidebook//core-modules/modularization/cross-module-constant"><span>跨模块常量</span></a></li><li><a href="/javascript-guidebook//core-modules/modularization/dynamic-import"><span>动态加载</span></a></li></ul></li></ul></div></div><ul class="__dumi-default-layout-toc" role="slug-list"><li title="编译原理" data-depth="2" class=""><a href="/javascript-guidebook//core-modules/executable-code-and-execution-contexts/compilation/compilation#编译原理"><span>编译原理</span></a></li><li title="分词和词法分析" data-depth="3" class=""><a href="/javascript-guidebook//core-modules/executable-code-and-execution-contexts/compilation/compilation#分词和词法分析"><span>分词和词法分析</span></a></li><li title="解析和语法分析" data-depth="3" class=""><a href="/javascript-guidebook//core-modules/executable-code-and-execution-contexts/compilation/compilation#解析和语法分析"><span>解析和语法分析</span></a></li><li title="代码生成" data-depth="3" class=""><a href="/javascript-guidebook//core-modules/executable-code-and-execution-contexts/compilation/compilation#代码生成"><span>代码生成</span></a></li><li title="编译过程" data-depth="2" class=""><a href="/javascript-guidebook//core-modules/executable-code-and-execution-contexts/compilation/compilation#编译过程"><span>编译过程</span></a></li><li title="作用域" data-depth="3" class=""><a href="/javascript-guidebook//core-modules/executable-code-and-execution-contexts/compilation/compilation#作用域"><span>作用域</span></a></li><li title="编译过程详解" data-depth="3" class=""><a href="/javascript-guidebook//core-modules/executable-code-and-execution-contexts/compilation/compilation#编译过程详解"><span>编译过程详解</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="编译阶段"><a aria-hidden="true" href="#编译阶段"><span class="icon icon-link"></span></a>编译阶段</h1><h2 id="编译原理"><a aria-hidden="true" href="#编译原理"><span class="icon icon-link"></span></a>编译原理</h2><p>JavaScript 是一门编译语言。与传统的编译语言不同的是，JavaScript 不是提前编译的，编译结果也不能在分布式系统中进行移植。</p><p>在传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为 <strong>编译</strong>。</p><ul><li>分词 / 词法分析</li><li>解析 / 语法分析</li><li>代码生成</li></ul><h3 id="分词和词法分析"><a aria-hidden="true" href="#分词和词法分析"><span class="icon icon-link"></span></a>分词和词法分析</h3><p><strong>词法分析</strong>（Tokenizing / Lexing）这个过程会将由字符组成的字符串分解成有意义的代码块（对编程语言来说），这些代码块被称为 <strong>词法单元</strong>（Token）。</p><p>🌰 <strong>标准示例：</strong></p><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="const a = 2;
" data-status="copy"></button><div class="token-line"><span class="token keyword">const</span><span class="token plain"> a </span><span class="token operator">=</span><span class="token plain"> </span><span class="token number">2</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>这段程序通常会被分解成为下面这些词法单元：<code>var</code>、<code>a</code>、<code>=</code>、<code>2</code>、<code>;</code>。</p><p>空格是否会被当作词法单元，取决于空格在这门语言中是否具有意义。</p><p>分词（Tokenizing）和词法分析（Lexing）之间的主要差异在于词法单元的识别是通过有状态还是无状态的方式进行的。简单来说，如果词法单元生成器在判断 <code>a</code> 是一个独立的词法单元还是其他词法单元的一部分时，调用的是<strong>有状态的解析规则</strong>，那么这个过程就被称为<strong>词法分析</strong>。</p><h3 id="解析和语法分析"><a aria-hidden="true" href="#解析和语法分析"><span class="icon icon-link"></span></a>解析和语法分析</h3><p><strong>语法分析</strong>（Parsing） 这个过程是将词法单元流转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为 <a href="https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E8%AA%9E%E6%B3%95%E6%A8%B9" target="_blank" rel="noopener noreferrer">抽象语法树<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>（Abstract Syntax Tree，AST 在各大框架及 <a href="https://github.com/babel/babel" target="_blank" rel="noopener noreferrer">Babel<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中我们都会看到它的身影）。</p><h3 id="代码生成"><a aria-hidden="true" href="#代码生成"><span class="icon icon-link"></span></a>代码生成</h3><p>将 AST 转换为可执行代码的过程被称为<strong>代码生成</strong>。这个过程与语言、目标平台等息息相关。 抛开具体细节，简单来说就是有某种方法可以将 <code>var a = 2;</code> 的 AST 转化为一组机器指令：创建一个叫做 <code>a</code> 的变量（包括分配内存等），并将一个值存储在变量 <code>a</code> 中。</p><p>通过上述三个阶段，浏览器已经可以运行我们得到的<strong>可执行代码</strong>了，这三个阶段还有一个合称呼叫<strong>编译阶段</strong>。我们把之后对可执行代码的执行称为<strong>运行阶段</strong>。</p><h2 id="编译过程"><a aria-hidden="true" href="#编译过程"><span class="icon icon-link"></span></a>编译过程</h2><p>编译过程中的关键角色：</p><ul><li><strong>引擎：</strong>从头到尾负责整个 JavaScript 程序的编译及执行过程</li><li><strong>编译器：</strong>负责语法分析及代码生成等步骤</li><li><strong>作用域：</strong>负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限</li></ul><h3 id="作用域"><a aria-hidden="true" href="#作用域"><span class="icon icon-link"></span></a>作用域</h3><p>作用域就是变量（标识符）适用范围，控制着变量的可见性。</p><p>《You don‘t know js》对作用域的定义：</p><blockquote><p>使用一套严格的规则来分辨哪些标识符对那些语法有访问权限。</p></blockquote><p>《JavaScript 权威指南》中对变量作用域的描述：</p><blockquote><p>一个变量的作用域（Scope）是程序源代码中定义这个变量的区域。全局变量拥有全局作用域，在 JavaScript 代码中的任何地方都是有定义的。然而在函数内声明的变量只在函数体内有定义。它们是局部变量，作用域是局部性的。函数参数也是局部变量，它们只是在函数体内有定义。</p></blockquote><h3 id="编译过程详解"><a aria-hidden="true" href="#编译过程详解"><span class="icon icon-link"></span></a>编译过程详解</h3><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="const a = 2;
" data-status="copy"></button><div class="token-line"><span class="token keyword">const</span><span class="token plain"> a </span><span class="token operator">=</span><span class="token plain"> </span><span class="token number">2</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>通过以上论述可以得知，编译器首先会将这段代码分解成词法单元，然后将词法单元解构成一个树结构（AST），但是当编译器开始进行代码生成时，它对这段代码的处理方式会和预期的情况有所不同。</p><p>当我们看到这行代码，用伪代码与别人进行概括时，可能会表述为：为一个变量分配内存，并将其命名为变量 <code>a</code>，然后将值 2 保存到这个变量（内存）中。</p><p>然而，这并不完全正确。</p><p><strong>事实上编译器会进行如下操作：</strong></p><ol><li>执行流遇到 <code>var a</code>，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为<code>a</code>。</li><li>接下来编译器会为引擎生成运行所需的代码，这些代码被用来处理 <code>a = 2</code> 这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中，是否存在一个叫作 <code>a</code> 的变量，如果是，引擎就会使用这个变量；如果否，引擎就会继续查找该变量。</li></ol><p>总结起来就是：</p><ul><li><p>编译器在作用域声明变量（如果没有）</p></li><li><p>引擎在运行这些代码时查找该变量，如果作用域中有该变量则进行赋值</p></li></ul><p>在上面的第二步中，引擎执行运行时所需的代码时，会通过查找变量 <code>a</code> 来判断它是否已经声明过。查找的过程由作用域进行协助，但是引擎执行怎么查找，会影响最终的查找结果。</p><p>还是 <code>var a = 2;</code> 这个例子，引擎会为变量 <code>a</code> 进行 LHS 查询。当然还有一种 RHS 查询。</p><blockquote><p>那么 LHS 和 RHS 查询是什么呢？</p></blockquote><p>这里的 L 代表左侧，R 代表右侧。通俗且不严谨的解释 LHS 和 RHS 的含义就是：<strong>当变量出现在赋值操作的左侧时进行 LHS 查询，出现在右侧时进行 RHS 查询。</strong></p><p>那么描述的更准确的一点，RHS 查询与简单的查找某个变量的值毫无二致，而 LHS 查询则是试图找到变量的容器本身，从而可以对其赋值。</p><p>从这个角度说，RHS 并不是真正意义上的&quot;赋值操作的右侧&quot;，更准确的说是&quot;非左侧&quot;。所以，我们可以将 RHS 理解成 Retrieve his source value（取到它的源值），这意味着，&quot;得到某某的值&quot;。</p><p>那我们来看一段代码深入理解一下 LHS 与 RHS。</p><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="function foo(a) {
  console.log(a)
}

foo(2)
" data-status="copy"></button><div class="token-line"><span class="token keyword">function</span><span class="token plain"> </span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token plain">a</span><span class="token punctuation">)</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div></pre></div><ul><li>在 <code>console.log(a)</code> 中，变量 <code>a</code> 的引用是一个 RHS 引用，因为我们是取到 <code>a</code> 的值。并将这个值传递给 <code>console.log(…)</code> 方法</li><li>相比之下，例如： <code>a = 2</code> ，调用 <code>foo(2)</code> 时，隐式的进行了赋值操作。这里对 <code>a</code> 的引用就是 LHS 引用，因为我们实际上不关心当前的值时什么，只要想把 <code>=2</code> 这个赋值操作找到一个目标。</li></ul><p>LHS 和 RHS 的含义是 <strong>赋值操作的左侧或右侧</strong> 并不一定意味着就是 <code>= 赋值操作符的左侧或右侧</code>。</p><p>赋值操作还有其他几种形式，因此在概念上最好将其理解 <strong>赋值操作的目标是谁</strong>（LHS） 以及 <strong>谁是赋值操作的源头</strong>（RHS）。</p><p>当然上面的程序并不只有一个 LHS 和 RHS 引用：</p><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="function foo(a) {
  // 这里隐式的进行了对形参 a 的 LHS 引用。

  // 这里对 log() 方法进行了 RHS 引用，询问 console 对象上是否有 log() 方法。
  // 对 log(a) 方法内的 a 进行 RHS 引用，取到 a 的值。
  console.log(a);
  // 2
}

// 此处调用 foo() 方法，需要调用对 foo 的 RHS 引用。意味着&quot;去找foo这个值，并把它给我&quot;
foo(2)
" data-status="copy"></button><div class="token-line"><span class="token keyword">function</span><span class="token plain"> </span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// 这里隐式的进行了对形参 a 的 LHS 引用。</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// 这里对 log() 方法进行了 RHS 引用，询问 console 对象上是否有 log() 方法。</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// 对 log(a) 方法内的 a 进行 RHS 引用，取到 a 的值。</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token plain">a</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// 2</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token comment">// 此处调用 foo() 方法，需要调用对 foo 的 RHS 引用。意味着&quot;去找foo这个值，并把它给我&quot;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>需要注意的是：我们经常会将函数声明 <code>function foo(a) <!-- -->{<!-- -->...<!-- -->}<!-- --> </code> 转化为普通的变量赋值（函数表达式） <code>var foo = function(a) <!-- -->{<!-- -->…<!-- -->}</code>，这样去理解的话，这个函数是 LHS 查询。但是有一个细微的差别，编译器可以在代码生成的同时处理声明和值的定义，比如引擎执行代码时，并不会有线程专门用来将一个函数值&quot;分配给&quot; <code>foo</code>，因此，将函数声明理解成前面讨论的 LHS 查询和赋值的形式并不合适。</p><blockquote><p>💡 综上所述，作用域是一套 <strong>标识符的查询规则</strong>（注意这里的用词是<strong>规则</strong>），JavaScript 编译引擎执行时根据查找的目的进行 LHS 与 RHS 查询。这套查询规则确定标识符在何处（当前作用域、上层作用域或全局作用域）以及如何查找（LHS、RHS）。</p></blockquote></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/tsejx/javascript-guidebook/edit/master/docs/core-modules/executable-code-and-execution-contexts/compilation/compilation.md">Edit this doc on GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="Last Update: ">9/19/2020, 3:55:47 PM</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script src="/javascript-guidebook/umi.js"></script>
    <script src="/javascript-guidebook/docs__core-modules__executable-code-and-execution-contexts__compilation__compilation.md.js"></script>
  </body>
</html>
