# 事件处理程序

事件就是用户或浏览器自身执行的某种动作。诸如 click、load和mouseover，都是事件的名字。而响应某个事件的函数就叫做**事件处理程序（或事件侦听器）**。事件处理程序的名字以“on”开头，因此click事件的事件处理程序就是onclick，load事件的事件处理程序就是onload。为事件指定处理程序的方式有好几种

## HTML 事件处理程序

某个元素支持的每种事件，都可以使用一个与相应事件处理程序同名的HTML特性来指定。这个特性的值应该是能够执行的Javascript代码

　　在事件处理程序函数内部，this值等于事件的目标元素

```html
<div id="box" style="height:30px;width:200px;background-color:pink;"onclick = "this.innerHTML+= '1';"></div>
```

　　在HTML中定义的事件处理程序也可以调用在页面其他地方定义的脚本

```html
<div id="box" style="height:30px;width:200px;background-color:pink;"onclick = "test()"></div>
<script>
    function test(){box.innerHTML+= '1';}    
</script>
```

　　HTML事件处理程序会创建一个封装着元素属性值的函数。这个函数中有一个局部变量event，也就是事件对象。通过event变量，可以直接访问事件对象，不用自己定义它，也不用从函数的参数列表中获取

```html
<div id="box" style="height:30px;width:200px;background-color:pink;"onclick = "this.innerHTML+= event.type;"></div>
```

　　在事件处理程序函数内部，可以像访问局部变量一样访问document及该元素本身的成员。如此一来，事件处理程序要访问自己的属性就简单多了

```html
<button id="box" value="test" style="height:30px;width:200px;background-color:pink;"onclick = "this.innerHTML+= value;"></button>
```

缺点

【1】时差问题

　　因为用户可能会有HTML元素一出现在页面上时就触发相应的事件，但当时的事件处理程序有可能尚不具备执行条件，就会报错

```html
<button style="height:30px;width:200px;background-color:pink;"onclick = "this.innerHTML+= val;"></button>
<script src="http://www.qq.com/test.js"></script>
<script>
var val=123;
</script>
```

【2】耦合问题

　　 客户端编程的通用风格是保持HTML内容和javaScript行为分离，所以应该避免使用HTML事件处理程序属性，因为这些属性直接混合了javascript和HTML，且不易扩展

## DOM0 级事件处理程序

通过Javascript指定事件处理程序的传统方式，就是将一个函数赋值给一个事件处理程序属性。这种为事件处理程序赋值的方法是在第四代Web浏览器中出现的，而且至今仍然为所有现代浏览器所支持。原因一是简单，二是具有跨浏览器的优势。

　　每个元素都有自己的事件处理程序属性，这些属性通常全部小写，将这种属性的值设置为一个函数，就可以指定事件处理程序。

　　[注意]以DOM0级方式添加的事件处理程序会在事件流的冒泡阶段被处理

```html
<div id="box" style="height:30px;width:200px;background-color:pink;"></div>
<script>
    box.onclick = function(){this.innerHTML += '1';}    
</script>    
```

　　可以通过将事件处理程序属性设置为null来删除事件处理程序

```javascript
box.onclick = null;
```

**缺点**

　　DOM0级事件处理程序的缺点是围绕着每个事件目标对于每种事件类型只能添加一个事件处理程序

## DOM2 级事件处理程序

　DOM2级事件处理程序定义了两个方法用于处理指定和删除事件处理程序的操作：`addEventListener()`和`removeEventListener()`

　　所有DOM节点中都包含这两个方法，并且它们都接受3个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后的布尔值参数如果是 `true`，表示在捕获阶段调用事件处理程序；如果是 `false`，表示在冒泡阶段调用事件处理程序。若最后的布尔值不填写，则和 `false` 效果一样。
 
　　[注意]IE8-浏览器不支持DOM2级事件处理程序

　　使用DOM2级事件处理程序的好处是可以添加多个事件处理程序，并按照他们添加的顺序触发

　　以下代码以1-2的顺序输出

```html
<div id="box" style="height:30px;width:200px;background-color:pink;"></div>
<script>
box.addEventListener('click',function(){this.innerHTML += '1'},false);
box.addEventListener('click',function(){this.innerHTML += '2'},false);    
</script>    
```

　　以下代码以2-1的顺序输出

```html
<div id="box" style="height:30px;width:200px;background-color:pink;"></div>
<script>
setTimeout(function(){
box.addEventListener('click',function(){this.innerHTML += '1'},false);    
},16);
box.addEventListener('click',function(){this.innerHTML += '2'},false);    
</script>
```


**参数**

　　如果希望向监听函数传递参数，可以用匿名函数包装一下监听函数

```html
<div id="box" style="height:30px;width:200px;background-color:pink;"></div>
<script>
box.addEventListener("click",function(){
    test('123');
},false);
function test(x){box.innerHTML += x;}
</script>
```


**移除**

　　通过 `addEventListener()`添加的事件处理程序只能使用 `removeEventListener()` 来移除，移除时传入的参数与添加处理程序时使用的参数相同。这意味着，`addEventListener()`添加的匿名函数将无法移除　　

　　以下无效

```html
<div id="box" style="height:30px;width:200px;background-color:pink;"></div>
<script>
box.addEventListener("click",function(){
    this.innerHTML += '1'
},false);
box.removeEventListener('click',function(){
    this.innerHTML += '1'
},false);    
</script>
```


　　以下有效

```html
<div id="box" style="height:30px;width:200px;background-color:pink;"></div>
<script>
var handle = function(){this.innerHTML += '1'};
box.addEventListener("click",handle,false);
box.removeEventListener('click',handle,false);    
</script>
```

## IE事件处理程序

　IE实现了与DOM中类似的两个方法：`attachEvent()` 和 `detachEvent()`。这两个方法接受相同的两个参数：事件处理程序名称与事件处理程序函数。由于IE8-浏览器只支持事件冒泡，所以通过 `attachEvent()` 添加的事件处理程序都会被添加到事件冒泡阶段

　　`attachEvent()`方法的第一个参数是"onclick"，而非DOM的 `addEventListener()` 方法中的"click"

```html
<div id="box" style="height:30px;width:200px;background-color:pink;"></div>
<script>
box.attachEvent('onclick',function(){this.innerHTML += '1';});
</script>
```

 　　[注意] `attachEvent()` 方法只冒泡到document，且IE10-浏览器支持

```html
<div id="box" style="height:30px;width:200px;background-color:pink;"></div>
<button id="reset">还原</button>
<script>
//IE10-浏览器返回div body html document
//其他浏览器报错
reset.onclick = function(){history.go();}
box.attachEvent('onclick',function(){box.innerHTML += 'div\n';});
document.body.attachEvent('onclick',function(){box.innerHTML += 'body\n';});
document.documentElement.attachEvent('onclick',function(){box.innerHTML += 'html\n';});
document.attachEvent('onclick',function(){box.innerHTML += 'document\n';});
window.attachEvent('onclick',function(){box.innerHTML += 'window\n';});
</script>    
```

**this**

　　与其他三个事件处理程序不同，IE事件处理程序的 `this` 指向 `window`，而非被绑定事件的元素。

```html
<!-- <div> -->
<div id="box" style="height:100px;width:300px;background-color:pink;" onclick = "console.log(this)"></div>
```

```html
<div id="box" style="height:100px;width:300px;background-color:pink;"></div>
<script>
    box.onclick= function(){
        console.log(this);//<div>
    }
</script>
```

```html
<div id="box" style="height:100px;width:300px;background-color:pink;"></div>
<script>
    box.addEventListener('click',function(){
        console.log(this);//<div>
    });
</script>
```

```html
<div id="box" style="height:100px;width:300px;background-color:pink;"></div>
<script>
    box.attachEvent('onclick',function(){
        console.log(this);//window
    });
</script>
```

**顺序**

　　使用 `attachEvent()` 方法添加的事件处理程序的触发顺序是有区别的。IE9、10浏览器是按正序执行的，而IE8-浏览器则是按倒序执行的。

```html
<div id="box" style="height:30px;width:100px;background-color:pink;"></div>
<script>
    box.attachEvent('onclick',function(){
        box.innerHTML += '1';
    });
    
    box.attachEvent('onclick',function(){
        box.innerHTML += '2';
    });
</script>
```


**移除**

　　使用 `attachEvent()`添加的事件可以通过 `detachEvent()`来移除，条件是必须提供相同的参数。与DOM方法一样，这也意味着添加的匿名函数将不能被移除。不过，只要能够将对相同函数的引用传给 `detachEvent()`，就可以移除相应的事件处理程序　　

　　以下无效

```html
<div id="box" style="height:30px;width:200px;background-color:pink;"></div>
<script>
box.attachEvent("onclick",function(){
    box.innerHTML += '1'
},false);
box.detachEvent('onclick',function(){
    box.innerHTML += '1'
},false);    
</script>
```

　　以下有效

```html
<div id="box" style="height:30px;width:200px;background-color:pink;"></div>
<script>
    var handle = function(){box.innerHTML += '1'};
    box.attachEvent("onclick",handle,false);
    box.detachEvent('onclick',handle,false);    
</script>    
```

## 跨浏览器的事件处理程序

为了以跨浏览器的方式处理事件，不少开发人员会使用能够隔离浏览器差异的JavaScript库，还有一些开发人员会自己开发最合适的事件处理的方法。自己编写代码其实也不难，只要恰当地使用能力检测即可。要保证处理事件的代码能在大多数浏览器下一致运行，只需关注冒泡阶段。

第一个要创建的方法是 `addHandler()`，它的职责是视情况分别使用DOM0级方法、DOM2级方法或IE方法来添加事件。这个方法属于一个名叫 `EventUtil` 的对象，本书将使用这个对象来处理浏览器间的差异。`addHandler()` 方法接受3个参数：要操作的元素、事件名称和事件处理程序函数。

与 `addHandler()` 对应的方法是 `removeHandler()`，它也接受相同的参数。这个方法的职责是移除之前添加的事件处理程序——无论该事件处理程序是采取什么方式添加到元素中的，如果其他方法无效，默认采用DOM0级方法。

`EventUtil`的用法如下所示

```javascript
var EventUtil = {
    addHandler: function(element, type, handler){
    if (element,.addEventListener) {
        element.addEventListener(type, handler, false);
    } else if (element.attachEvent) {
        element.attachEvent('on' + type, handler);
    } else {
        element["on" + type] = handler;
    }
    removeHandler: function(element, type, handler) {
        if (element.removeEventListener) {
            element.removeEventListener(type, handler, false);
        } else if (element.detachEvent) {
            element.detachEvent("on" + type, handler);
        } else {
            element["on" + type] = handler;
        } else {
            element["on" + type] = null;
        }
    }
}
```

这两个方法首先都会检测传入的元素中是否存在DOM2级方法。如果存在DOM2级方法，则使用该方法：传入事件类型、事件处理程序函数和第三个参数 `false` （表示冒泡阶段）。如果存在的是IE的方法，则采取第二种方案。注意，为了在IE8及更早版本中运行，此时的事件类型必须加上"on"前缀。最后一种可能就是使用DOM0级方法（在现代浏览器中，应该不会执行这里的代码）。此时，我们使用的是方括号语法来将属性名指定为事件处理程序，或者将属性设置为`null`。

可以像下面这样使用 `EventUtil`对象：

```javascript
var btn = document.getElementById("myBtn");
var handler = function (){
    alert("Clicked");
}
EventUtil.addHandler(btn, "click", handler);
// 这里省略了其他代码
EventUtil.removeHandler(btn, "click", handler);
```

`addHandler()`和`removeHandler()`没有考虑到所有的浏览器问题，例如在IE中的作用域问题。不过，使用它们添加和移除事件处理程序还是足够了。此外还要注意，DOM0级对每个事件只支持一个事件处理程序。好在，只支持DOM0级的浏览器已经没有那么多了，因此这对你而言应该不是什么问题。


