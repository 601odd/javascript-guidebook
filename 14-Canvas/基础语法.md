# 基础语法

canvas顾名思义是定义在浏览器中的画布。它不仅是一个普通的元素，更是一个强大的编程工具。它的出现已然超过了web基于文档的设计初衷，将网页这一形态的应用推向了另一个高度。利用canvas，可以开发出复杂的动画、动态图表、游戏等。关于canvas，有这样一句话——canvas就像是一场文艺复兴，将编程工作者彻底释放出创造力。

## 基本语法

在HTML中添加Canvas非常简单，只需要在HTML的<body>部分，添加上 `<canvas>` 标签就可以了

```html
<canvas>
    <p>The canvas element is not supported!</p>
</canvas>
```

现在，页面是一个完完全全的空白页面。Canvas的本意是画布，画布在HTML5中是透明的，是不可见的。

canvas支持HTML属性高度 `height` 和宽度 `width`，可以在开始和结束标签之间加入HTML来提供后备内容。

 - `height` 高度
 - `width` 宽度

```html
<canvas width="600" height="300">
    <p>The canvas element is not supported!</p>
</canvas>
```

　[注意]重置canvas的宽或高可以达到清空画布的效果
 
  [注意]通过CSS样式设置的宽高，是canvas元素的实际占据宽高；通过属性值设置的宽度，是canvas内部编程的设置宽高；如果没有通过CSS样式设置宽度，则canvas元素实际占据宽高等于内容编程设置宽度
  
  如果按照如下进行设置，则canvas的最终宽高为400*100，相当于内部元素宽度缩小2.5倍，高度缩小2倍

```javascript
    canvas.width = 1000;
    canvas.height = 200;
    canvas.style.width = '400px';  
    canvas.style.height = '100px'; 
```

　　如果按照如下进行设置，则canvas的最终宽高为400*40，相当于内部元素宽度和高度等比例缩小2.5倍

```javascript
    canvas.width = 1000;
    canvas.height = 200;
    canvas.style.width = '400px';  
```

## 绘图上下文

要在canvas上绘图，需要以下三个步骤

　　1、布置画布：通过添加 `<canvas>` 标签，添加canvas元素

　　2、获取画布：通过 `<canvas>` 标签的id，获得canvas对象

　　3、取得绘图上下文：通过canvas对象的 `getContext("2d")` 方法，获得2D环境；如果要获取三维上下文，使用 `webgl`

　　上面的三个步骤对应如下代码

```html
<canvas id=“canvas”></canvas>
<script>
var canvas = document.getElementById("canvas");
var context = canvas.getContext("2d")
</script>
```

### canvas坐标

　　使用2D上下文提供的方法可以绘制简单的2D图形，比如矩形、弧线和路径。2D上下文坐标开始于canvas元素的左上角，原点坐标是(0,0)。所有坐标值都基于这个原点计算，x值越大表示越靠右，y值越大表示越靠下。默认情况下，width和height表示水平和垂直两个方向上可用的像素数目。
　　
![canvas坐标][1]


## 填充和描边

2D上下文的两种基本绘图操作是填充和描边

填充是指用指定的样式(颜色、渐变和图像)填充图形；描边是只在图形的边缘画线

　　大多数2D上下文操作都会细分为填充和描边两个操作，而操作的结果取决于两个属性:`fillStyle`和`strokeStyle`。这两个属性的值可以是字符串、渐变对象或模式对象，而且它们的默认值都是 `#000000` 。如果为它们指定表示颜色的字符串值，可以使用CSS中指定颜色值的任何格式，包括颜色明、十六进制码、rgb、rgba、hsl或hsla。举个例子：

```javascript
var context = drawing.getContext('2d');
context.strokeStyle="red";
context.fillStyle="#00f";
```

## 绘制矩形

下面先从最简单的矩形绘制开始说起，矩形是唯一一种可以直接在2D上下文中绘制的形状，与矩形相关的方法包括`fillRect()`、`strokeRect()`、`clearRect()`。

这三个方法都能接收4个参数：

- 矩形的x坐标
- 矩形的y坐标
- 矩形宽度
- 矩形高度

这些参数的单位都是像素


 - `fillRect(x,y,w,h)`:画布上绘制的矩形会填充通过fillStyle属性指定的颜色。
 - `strokeRect(x,y,w,h)`:画布上绘制的矩形会使用通过strokeStyle属性指定描边颜色。
 - `clearRect(x,y,w,h)`:用于清除画布上的矩形区域。本质上这个方法可以把绘制上下文中的某一矩形区域变透明。通过绘制形状然后再清除指定区域，就可以生成有意思的效果。


　　下面来绘制一个背景颜色为红色，尺寸为100*100，位置为(0,0)点的矩形

```html
<canvas id="drawing" style="border:1px solid black">
    <p>The canvas element is not supported!</p>
</canvas>
<script>
var drawing = document.getElementById('drawing');
//确定浏览器支持<canvas>元素
if(drawing.getContext){
    var context = drawing.getContext('2d');
    context.fillRect(0,0,100,100);
    context.fillStyle = 'red';
} 
</script>
```

　　结果如下，背景颜色为黑色。这是因为，使用fillRect()方法时，会使用当前的fillStyle值。由于当前还没有设置，所以会使用默认的黑色值


　　进行如下修改后，结果符合预期

```javascript
var drawing = document.getElementById('drawing');
if(drawing.getContext){
    var context = drawing.getContext('2d');
　　 context.fillStyle = 'red';
　　 context.fillRect(0,0,100,100);
}
```

　　下面来绘制一个半透明的蓝色描边矩形，尺寸为100*100，位置在(0,0)点

```
var drawing = document.getElementById('drawing');
if(drawing.getContext){
    var context = drawing.getContext('2d');
　　 context.strokeStyle = 'rgba(0,0,255,0.5)';
　　 context.strokeRect(0,0,100,100);
}
```

 　　接下来，在(0,0)点绘制尺寸为100*100背景为半透明红色的矩形， 1s后在(50,50)点绘制尺寸为100*100，描边为半透明蓝色的矩形，1s后使用clearRect()清除矩形

```html
<canvas id="drawing" style="border:1px solid black">
    <p>The canvas element is not supported!</p>
</canvas>
<script>
var drawing = document.getElementById('drawing');
if(drawing.getContext){
    var context = drawing.getContext('2d');
    context.fillStyle = 'rgba(255,0,0,0.5)';
    context.fillRect(0,0,100,100);
    setTimeout(function(){
      context.strokeStyle = 'rgba(0,0,255,0.5)';
      context.strokeRect(50,50,100,100);  
    },1000);
    setTimeout(function(){
      context.clearRect(0,0,300,150);
    },2000);    
} 
</script>
```

## 绘制路径

beginPath()

cloasePath()

## 绘制文本

fillText()

strokeText()

## 变换

rotate(angle)

scale(scaleX, scaleY)

translate(x, y)

transform(m1_1, m1_2, m2_1, m2_2, dx, dy)

setTransform(m1_1, m1_2, m2_1, m2_2, dx, dy)

## 绘制图像

drawImage()

## 阴影

shadowColor

shadowOffsetX

shadowOffsetY

shadowBlur

## 渐变

## 模式

## 使用图像数据

## 合成


  [1]: https://images2015.cnblogs.com/blog/740839/201512/740839-20151219104712006-1891188943.jpg