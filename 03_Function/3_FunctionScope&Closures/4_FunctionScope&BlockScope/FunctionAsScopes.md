# 函数作用域

在任意代码片段外部添加包装函数，可以将内部的变量和函数定义“隐藏”起来，外部作用域无法访问包装函数内部的任何内容。

```js
var a = 2;

function foo() { // <-- 添加这一行
    var a = 3;
    console.log( a );	// 3
}	// <-- 以及这一行
foo();	// <-- 以及这一行

console.log( a );	// 2
```

虽然这种技术可以解决一些问题，但是它并不理想，因为会导致一些额外的问题。首先，必须声明一个具名函数 `foo()` ，意味着 foo 这个名称本身“污染”了所在作用域（在这个例子中是全局作用域）。其次，必须显式地通过函数名（`foo()`）调用这个函数才能运行其中的代码。
如果函数不需要函数名（或者至少函数名可以不污染所在作用域），并且能够自动运行，这将会更加理想。

## 匿名和具名

无论是匿名还是具名，都是针对函数表达式的。函数声明必须有名称，否则报错。

```js
function foo(){	
    // do something
}
```

而函数表达式可以有名称也可以没有名称。

```js
let foo = function(){...}
console.log(foo.name);	// foo
                     
let bar = function foobar(){...};	// 不要这样写
console.log(bar.name);	// foobar
```

对于函数表达式最熟悉的场景可能就是回调参数了。

```js
setTimeout( function(){
    console.log("I waited 1 second!");
}, 1000);
```

这叫匿名函数表达式，因为 `function()...` 没有名称标识符。函数表达式可以是匿名的，而函数声明则不可以省略函数名——在 JavaScript 的语法中这是非法的。

但是匿名函数表达式的缺点需要考虑：

1. 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。

2. 如果没有函数名，当函数需要引用自身时只能使用已经过期的 `arguments.callee` 引用，比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。

3. 匿名函数省略了对于代码可读性/可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。

行内函数表达式非常强大且有用——匿名和具名之间的区别并不会对这点有任何影响。给函数表达式指定一个函数名可以有效解决以上问题。始终给函数表达式命名时一个最佳实践。

## 立即执行函数表达式

立即执行函数表达式又称自执行函数，社区给他规定了术语曰 IIFE（Immediately Invoked Function Expression）。

```js
// 用法
(function (){
    // ...
})()

(function (){
    
}())
```

为立即执行函数表达式加上函数名，则能同时拥有具名函数表达式的优势，因此也是一个值得推广的实践。

```js
(function IIFE(){
    // ..
})()
```

IIFE 的另一个非常普遍的进阶用法是把它们当作函数调用并传递参数进去。

```js
var a = 2;

(function IIFE(global){
    var a = 3;
    console.log( a );				// 3
    console.log( global.a );		// 2
})(window)

console.log( a );					// 2
```



