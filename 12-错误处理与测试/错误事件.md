# 错误事件

tags: 前端生存指南

任何没有通过 `try-catch` 处理的错误都会触发 `window` 对象的 `error` 事件。在任何Web浏览器中，`onerror` 事件处理程序都不会创建 `event` 对象，但它可以接收三个参数：错误信息、错误所在的URL和行号。多数情况下，只有错误消息有用，因为URL知识给出了文档的位置，而行号所指的代码行既可能出自嵌入的JavaScript代码，也可能出自外部的文件。要指定 `onerror` 事件处理程序，必须使用如下所示的DOM0级技术，它没有遵循“DOM2级事件”的标准格式。

```javascript
window.onerror = function (message, url, line){
    alert(messge);
}
```

只要发生错误，无论是不是浏览器生成的，都会触发 `error` 事件，并执行这个事件处理程序。然后，浏览器默认的机制发挥作用，像往常一样显示错误消息。像下面这样在事件处理程序中返回 `false`，可以阻止浏览器报告错误的默认行为。

```javascript
window.onerror = function (message, url, line){
    alert(messge);
    return false;
}
```

通过返回 `false`，这个函数实际上就充当了整个文档中的`try-catch` 语句，可以捕获所有物代码处理的运行时错误。这个事件处理程序是避免浏览器报告错误的最后一道防线，理想情况下，只要可能就不应该使用它。只要能够适当地使用 `try-catch` 语句，就不会有错误交给浏览器，也就不会触发 `error` 事件。

## 常见的错误类型

由于 JavaScript  是松散类型的，而且也不会验证函数的参数，因此错误只会在代码运行期间出现。一般来说，需要关注三种错误：

 - 类型转换错误
 - 数据类型错误
 - 通信错误

### 类型转换错误

建议使用全等（`===`）和非全等（`!==`）操作符，以避免类型转换

```javascript
console.log(5 == '5'); // true
console.log(5 === '5'); // false
console.log(1 == true); // true
console.log(1 === true); //false
```

使用权等和非权等操作符，可以避免发生因为使用相等和非相等操作符引发得到类型转换错误，因此我们强烈推荐使用。

容易发生类型转换错误的另一个地方，就是流控制语句。像if之类的语句在确定下一步操作之前，会自动把任何值转换成布尔值。尤其是if语句，如果使用不当，最容易出错。

```javascript
function concat(str1, str2, str3){
    var result = str1 + str2;
    if (str3){  // 绝对不要这样！！！
        result += str3;
    }
    return result;
}
```

这个函数的用意是拼接两或三个字符串，然后返回结果。其中，第三个字符串是可选的，因此必须要检查。未使用过的命名变量会自动被赋予 `undefined` 值。而 `undefined` 值可以被转换成布尔值 `false`，因此这个函数中的if语句实际上只适用于提供了第三个参数的情况。问题在于，并不是只有 `undefined` 才会被转换成 `false`，也不是只有字符串才可以转换成 `true`。例如，假设第三个参数是0，那么if语句的测试就会失败，而对数值1的测试则会通过。

在流控制语句中使用非布尔值，是极为常见的一个错误来源。为避免此类错误，就要做到在条件比较时切实传入布尔值。实际上，执行某种形式的比较就可以达到这个目的。例如，我们可以将前面的函数重写如下。

```javascript
function concat(str1, str2, str3){
    var result = str1 + str2;
    if (typeof str3 == 'string'){
        result += str3;
    }
    return result;
}
```

在这个重写后的函数中，if语句的条件会基于比较返回一个布尔值。这个函数相对可靠得多，不容易受非正常值的影响。

### 数据类型错误

JavaScript是松散类型的，也就是说，在使用变量和函数参数之前，不会对它们进行比较以确保它们的数据类型正确。为了保证不会发生数据类型错误，只能依靠开发人员编写适当的数据类型检测代码。在将预料之外的值传递给函数的情况下，最容易发生数据类型错误。

```javascript
// 不安全的函数，任何非字符串值都会导致错误
function getQuertString(url) {
    var pos = url.indexOf('?');
    if (pos > -1){
        return url.substring(pos + 1);
    }
    return '';
}
```

这个函数的用意是返回给定URL中的查询字符串。为此，它首先使用 `indexoOf()` 寻找字符串中的问号。如果找到了，利用 `substring()` 方法返回问号后面的所有字符串。这个例子中的两个函数只能操作字符串，因此只要传入其他数据类型的值就会导致错误。而添加一条简单的类型检测语句，就可以确保函数不那么容易出错。

```javascript
function getQueryString(url) {
    if (typeof url == 'string'){
        var pos = url.indexOf('?');
        if (pos > -1){
            return url.substring(pos + 1);
        }
    }
}
```

在流控制语句中使用非布尔值作为条件很容易导致类型转换错误。同样，这样做也经常会导致数据类型错误。

```javascript
// 不安全的函数，任何非数组值都会导致错误
function reverseSort(values) {
    if (values) {   // 绝对不要这样！！
        values.sort();
        values.reverse();
    }
}
```

这个 `reverseSort()` 函数可以将数组反向排序，其中用到了 `sort()` 和 `reverse()` 方法。对于if语句中的控制条件而言，任何会转换为 `true` 的非数组值都会导致错误。

另一个常见的错误就是将参数与 `null` 值进行比较。

```javascript
// 不安全的函数，任何非数组值都会导致错误
function reversort(values){
    if (values != null){    // 绝对不要这样
        values.sort();
        values.reverse();
    }
}
```

与 `null` 进行比较只能确保相应的值不是 `null` 和 `undefined`（这就相当于使用相等和不相等操作）。要确保传入的值有效，仅检测 `null` 值是不够的；因此，不应该使用这种技术。同样，我们也不推荐将某个值与 `undefined` 作比较。

另一种错误的做法，就是只针对要使用的某一个特征执行特性检测。

```javascript
// 还是不安全，任何非数组值都会导致错误
function reverseSort(values){
    if (typeof values.sort == 'function'){
        values.sort();
        values.reverse();
    }
}
```
