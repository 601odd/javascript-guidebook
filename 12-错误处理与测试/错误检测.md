# 错误检测

程序开发中，编程人员经常要面对的是如何编写代码来响应错误事件的发生，即**例外处理（exception handlers）**。如果例外处理代码设计得周全，那么最终呈现给用户的就将是一个友好的界面。否则，就会让访问者对莫名的现象感到真正的“意外”。

当JavaScript程序在运行中发生了诸如数组索引越界、类型不匹配或者语法错误时，JavaScript解释器就会引发例外处理。ECMAScript定义了六种类型的错误，除此之外，我们可以使用 Error对象 和 throw语句 来创建并引发自定义的例外处理信息。

## 测试和捕捉（try-catch语句）

在JavaScript中，我们使用 `try-catch` 语句来处理异常，即通过它来捕捉错误发生后导致的例外或者执行 `throw`语句产生的例外。

```javascript
try {
    // 此处是可能产生异常的代码块
} catch (error) {
    // 此处是负责处理异常的代码块
}
```

如果 `try` 块中的任何代码发生了错误，就会立即退出代码执行过程，然后接着执行 `catch` 块。此时， `catch` 块会接收到一个包含错误信息的对象。

 
### finally子句

 - `try` 语句块中的代码全部正常执行，`finally` 子句会执行 
 - 如果因为出错而执行了 `catch` 语句块，`finally` 子句照样还会执行
 - 只要代码中包含 `finally` 子句，则无论 `try` 或 `catch` 语句块中包含什么代码——甚至 `return` 语句，都不会阻止 `finally` 子句的执行
 
```javascript
try {
    // tryStatements
} catch (exception) {
    // catchStatements
} finally {
    // finallyStatements
}
```

如果提供 `finally` 子句，则 `catch` 子句就成了可选的（`catch` 或 `finally` 有一个即可）

### 错误类型

执行代码期间可能会发生的错误有很多种类型。每种错误都有对应的错误类型，而当错误发生时，就会抛出相应类型的错误对象。

 - `Error`
 - `EvalError`
 - `RangeError`
 - `SyntaxError`
 - `TypeError`
 - `URIError`

其中，`Error` 是基类型，其他错误类型都继承自该类型。因此，所有错误类型共享了一组相同的属性（错误对象中的方法全是默认的对象方法）。`Error` 类型的错误很少见，如果有也是浏览器抛出的，这个基类型的主要目的是供开发人员抛出自定义错误的。

**EvalError**

`EvalError` 类型的错误会在使用 `eval()` 函数而发生异常时被抛出。如果以非直接调用的方式使用 `eval` 属性的值（换句话说，没有明确地将其名称作为一个Identifier，即用作CallExpression中的MemberExpression），或者为 `eval` 属性赋值。简单地说，如果没有把 `eval()` 当成函数调用，就会抛出错误。

```javascript
new eval(); // 抛出EvalError
eval = foo; // 抛出EvalError
```

**RangeError**

`RangeError` 类型的错误会在数值超出相应范围时触发。例如，在定义数组时，如果指定了数组不支持的项数（如-20或 `Number.MAX_VALUE`），就会触发这种错误。

```javascript
let items1 = new Array(-20);    //  抛出RangeError
let items2 = new Array(Number.MAX_VALUE);   //  抛出RangeError
```

**ReferenceError**

在找不到对象的情况下，会发生ReferenceError 异常。通常，在访问不存在的变量时，就会发生这种错误。

```javascript
let obj = x;    // 在x并未声明的情况下抛出 RangeError
```

**SyntaxError**

当我们把语法错误的 JavaScript 字符串传入 `eval()` 函数时，就会导致此类错误。

```javascript
eval('a ++ b');     // 抛出 SyntaxError
```

如果语法错误的代码出现在 `eval()` 函数之外，则不太可能使用 `SyntaxError` ，因为此时的语法错误会导致 JavaScript 代码立即停止执行。


**TypeError**

TypeError 类型在 JavaScript 中会经常用到，在变量中保存着意外的类型时，或者在访问不存在的方法时，都会导致这种错误。错误的原因虽然多种多样，但归根结底还是由于在执行特定于类型的操作时，变量的类型并不符合要求所致。

```javascript
let o = new 10;     // 抛出 TypeError
alert('name' in true);      // 抛出 TypeError
Function.prototype.toString.call('name');   // 抛出 TypeError
```

最常发生类型错误的情况，就是传递给函数的参数事先未经检查，结果传入类型与预期类型不相符。

**URLError**

在使用 `encodeURL()` 或 `decodeURL()`，而 URL 格式不正确时，就会导致 URLError 错误。这种错误很少见，因为前面说的这两个函数的容错性非常高。

利用不同的错误类型，可以获悉更多哦有关异常的信息，从而有助于对错误做出恰当的处理。要想知道错误的类型，可以像下面这样在 `try-catch` 语句的 `catch` 语句中使用 `instanceof` 操作符。

```javascript
try {
    someFunction();
} catch (error) {
    if (error instanceof TypeError) {
        // 处理类型错误
    } else if (error instanceof ReferenceError) {
        // 处理引用错误
    } else {
        // 处理其他类型的错误
    }
}
```

在跨浏览器编程中，检查错误类型是确定处理方式的最简便途径，包含在 message 属性中的错误消息会因浏览器而异。


## 抛出异常（throw语句）

与 `try-catch` 语句相配的还有一个 `throw` 操作符，用于随时抛出自定义错误。抛出错误时，必须要给 `throw` 操作符指定一个值，这个值是什么类型，没有要求。

```javascript
throw 12345;
throw 'Hello world!';
throw true;
throw {name: 'JavaScript'};
```

在遇到 `throw` 操作符时，**代码会立即停止执行**。仅当有 `try-catch` 语句捕获到被抛出的值时，代码才会继续执行。

通过使用某种内置错误类型，可以更真实地模拟浏览器错误。每种错误类型的构造函数接受一个参数，即实际的错误消息。

```javascript
throw new Error('Something bad happened');
```

这行代码抛出一个通用错误，带有一条自定义错误消息。浏览器会像处理自己生成的错误一样，来处理这行代码抛出的错误。换句话说，浏览器会以常规方式报告这一错误，并且会显示这里的自定义错误消息。像下面使用其他错误类型，也可以模拟出类似的浏览器错误。

```javascript
throw new SyntaxError('I dont\'t like your syntax.');
throw new TypeError('What type of variable do you take me for?');
throw new RangeError('Sorry, you just don\'t have the range');
throw new EvalError('That doesn\'t evaluete');
throw new URLError('Uri, is that you?');
throw ReferenceError('You didn\'t cite your references properly');
```

利用原型链还可以通过继承 `Error` 来创建自定义错误类型。此时，需要为新创建的错误类型指定 `name` 和 `messge` 属性。

```javascript
function CustomError(messge) {
    this.name = 'Customer';
    this.messge = messge;
}

CustomError.prototype = new Error();
throw new CustomError('My messge');
```

浏览器对待继承自 `Error` 的自定义错误类型，就像对待其他错误类型一样。如果要捕获自己抛出的错误并且把它与浏览器错误区别对待的话，创建自定义错误是很有用的。








