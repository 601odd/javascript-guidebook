# 节点层次

tags: 前端生存指南

DOM 可以将任何HTML或XML文档描绘成一个由多层节点构成的结构。节点分为几种不同的类型，每种类型分别表示文档中不同的信息及（或）标记。每个节点都拥有各自的特点、数据和方法，另外也与其他节点存在某种关系。节点之间的关系构成了层次，而所有页面标记则表现为一个以特定节点为根节点的树形结构。以下面的HTML为例：

```html
<html>
    <head>
        <title>Sample Page</title>
    </head>
    <body>
        <p>Hello World!</p>
    </body>
</html>
```

文档节点是每个文档的根节点。在这个例子中，文档节点只有一个字节点，即 `<html>`元素，我们称之为文档元素。文档元素是文档的最外层元素，文档中的其他所有元素都包含在文档元素中。每个文档只能有一个文档元素。在HTML页面中，文档元素始终都是 `<html>`元素。在XML中，没有预定义的元素，因此任何元素都可能成为文档元素。

每一段标记都可以通过树中的一个节点来表示： HTML元素通过元素节点表示，特性（Attribute）通过特性节点表示，文档类型通过文档类型节点表示，而注释则通过注释节点表示。总共12种节点类型，这些类型都继承自一个基类型。



## Node 类型

一般地，节点至少拥有nodeType、nodeName和nodeValue这三个基本属性。节点类型不同，这三个属性的值也不相同

DOM1 级定义了一个Node接口，该接口将由DOM中的所有节点类型实现。这个Node接口在JavaScript中是作为Node类型实现的；除了IE之外，在其他所有浏览器中都可以访问到这个类型。JavaScript中的所有节点类型都继承自Node类型，因此所有节点类型都共享着相同的基本属性和方法。

每一个节点都有一个 nodeType 属性，用于表明节点的类型。节点类型由在Node类型中定义的下列12个数值常量来表示，任何节点类型必居其一。

### nodeType

nodeType属性返回节点类型的常数值。不同的类型对应不同的常数值，12种类型分别对应1到12的常数值

**常用节点**

节点名称|常量|值
:---:|:---:|:---:
元素节点|Node.ELEMENT_NODE|1
文本节点|Node.TEXT_NODE|3
处理指令节点|Node.PROCESSING_INSTRUCTION_NODE|7
注释节点|Node.COMMENT_NODE|8
文档节点|Node.DOCUMENT_NODE|9
文档类型节点|Node.DOCUMENT_TYPE_NODE|10
文档片段节点|Node.DOCUMENT_FRAGMENT_NODE|11

**废弃节点**

节点名称|常量|值
:---:|:---:|:---:
属性节点|Node.ELEMENT_NODE|2
CDATA节点|Node.TEXT_NODE|4
实体引用名称节点|Node.PROCESSING_INSTRUCTION_NODE|5
实体名称节点|Node.COMMENT_NODE|6
DTD声明节点 |Node.DOCUMENT_NODE|12

### nodeName

nodeName 属性返回节点的名称

### nodeValue

nodeValue 属性返回或设置当前节点的值，格式为字符串

## Document 类型

JavaScript 通过 Document 类型表示文档。在浏览器中,document 对象是 HTMLDocument(继承自Document类型)的一个实例,表示整个HTML页面。而且,document 对象是 window 对象的一个属性,因此可以将其作为全局对象来访问。Document节点具有下列特征：

- nodeType 的值为9
- nodeName 的值为 '#document'
- nodeValue 的值为 `null`
- parentNode 的值为 `null`
- ownerDocument 的值为 `null`
- 其字节点可能是一个DocumentType(最多一个)、Element(最多一个)、ProcessingInstruction或Comment

### 文档的子节点

```html
<html>
    <body>
    
    </body>
</html>
```

**document.documentElement**

这个页面经过解析后，其文档中只包含一个字节点，即 `<html>` 元素。可以通过 `documentElement` 或 `childNodes` 列表来访问这个元素。

```javascript
var html = document.documentElement; // 取得对<html>的引用
alert(html === document.childNodes[0]); // true
alert(html === document.firstChild); // true
```

**document.body**

```javascript
var body = document.body; // 取得<body>的引用
```

作为 `HTMLDocument` 的实例，document 对象还有一个body属性，直接指向 `<body>` 元素。

**document.doctype**

```javascript
var doctype = document.doctype; // 取得<!DOCTYPE>的引用
```

可以将 `<!DOCTYPE>` 标签看成一个与文档其他部分不同的实体，可以通过 `doctype` 属性(在浏览器中是document.doctype) 来访问它


## Element 类型

除了 Document 类型之外，Element 类型就要算是 Web编程中最常用的类型了。Element 类型用于表现XML或HTML元素，提供了对元素标签名、子节点及特性的访问。Element 节点具有以下特征：

- nodeType的值为 1
- nodeName 的值为元素的标签名
- nodeValue 的值为 `null`
- parentNode可能是Document或Element
- 其他子节点可能是Element、Text、Comment、ProcessingInstruction、EntityReference

要访问元素的标签名，可以使用 `nodeName` 属性，也可以使用 `tagName` 属性；这两个属性会返回相同的值（使用后者主要是为了清晰起见）

```html
<div id='myDiv'></div>
```

可以像下面这样取得这个元素及其标签名

```javascript
var div = document.getElementById('myDiv');
alert(div.tagName); // 'DIV'
alert(div.tagName === div.noadeName); // true
```

在HTML，标签名始终都以全部大写表示；而在XML中，标签名则始终会与源代码中的保持一致，假如你不确定自己的脚本将会在HTML还是XML文档中执行，最好是在比较之前将标签名转换为相同的大小写形式。

```javascript
if (element.tagName === 'div') {
    // do something
}

if (element.tagName.toLowerCase() == 'div') { // 这样最好（适用于任何文档）
    // do something
}
```

### HTML 元素

所有HTML元素都由HTMLElement类型表示，不是直接通过这个类型，也是通过它的子类型来表示。HTMLElement类型直接继承自Element并添加了一些属性。添加的这些属性分别对应于每个HTML元素中都存在的下列标准特性。

 - id，元素在文档中的唯一标识符
 - title，有关元素的附加说明信息，一般通过工具提示条显示出来
 - lang，元素内容的语言代码，很少使用
 - dir，语言的方向，值为'ltr'(left-to-right,从左至右)或'rtl'(right-to-left,从右至左)，也很少使用
 - className，与元素的class特性对应，即为元素指定的CSS类。没有将这个属性命名为class，是因为class是ECMAScript保留字

```html
<div id='myDiv' class='bd' title='Body text' lang='en' dir='ltr'></div>
```

```javascript
// 元素中指定的所有信息，都可以通过下列JavaScript代码取得
var div = document.getElementById('myDiv');

console.log(div.id); // 'myDiv'
console.log(div.className); // 'bd'
console.log(div.title); // 'Body text'
console.log(div.lang); // 'en'
console.log(div.dir); // 'ltr'

// 可通过为每个属性赋予新的值，修改对应的每个特性
div.id = 'someOtherId';
div.className = 'ft';
div.title = 'Some other text';
div.lang = 'fr';
div.dir = 'rtl';
```

### 取得特性

操作特性的DOM方法主要有三个：`getAttribute()`、`setAttribute()`、`removeAttribute()`

```javascript
var div = document.getElementById('myDiv');
console.log(div.getAttribute('id')); // 'myDiv'
console.log(div.getAttribute('class')); // 'bd'
console.log(div.getAttribute('lang')); // 'en'
console.log(div.getAttribute('dir')); // 'ltr'
```

[注意] 传递给`getAttribute()`的特性名与实际的特性名相同。因此要得到 `class` 特性值，应该传入 `class` 而不是 `className`，后者只有在通过对象属性访问特性时采用。如果给定名称的特性不存在，`getAttribute()`返回`null`

通过 `getAttribute()`方法也可以取得自定义特性(即标准HTML语言中没有的特性)的值，不过，特性的名称是不区分大小写的，即 ID 和 id 代表的都是同一个特性。另外，根据HTML5规范，自定义特性应该加上`data-`前缀以便验证。

任何元素的所有特性，也都可以通过DOM元素本身的属性来访问。当然，HTMLElement也会有5个属性与相应的特性一一对应。不过，只有公认的（非自定义的）特性才会以属性的形式添加到DOM对象中。

```html
<div id='myDiv' align='left' my_special_attribute='hello!'></div>
```

```javascript
console.log(div.id); // 'myDiv'
console.log(div.my_special_attribute); // undefined(IE除外)
console.log(div.align); // 'left'
```

有两类特殊的特性，它们虽然有对应的属性名，但属性的值与通过`getAttribute()`返回的值并不相同。

第一类特性是 `style`，在通过 `getAttribute()` 访问时，返回的 `style` 特性值中包含的是 CSS文本，而通过属性来访问它则会返回一个对象。由于 `style` 属性是用于编程方式访问元素样式的，因此并没有直接映射到 style 特性。

第二类是onclick这样的事件处理程序。当在元素上使用时，onclick特性中包含的是JavaScript代码，如果通过 `getAttribute()` 访问，则会返回相应代码的字符串。而在访问onclik属性时，则会返回一个JavaScript函数（如果未在元素中指定相应特性，则返回`null`）。这是因为 onclick 及其他事件处理程序属性本身就应该被赋予函数值。

由于存在这些差别，在通过 JavaScript 以编程方式操作 DOM时，开发人员经常不使用 `getAttribute()`，而是只使用对象的属性。只有在取得自定义特性值的情况下，才会使用`getAttribute()`方法。

### 设置特性

```javascript
div.setAttribute('id', 'someOtherId');
div.setAttribute('class', 'ft');
div.setAttribute('title', 'Some other text');
div.setAttribute('lang', 'fr');
div.setAttribute('dir', 'rtl');
```

通过 `setAttribute()` 方法既可以操作HTML特性也可以操作自定义特性。通过这个方法设置的特性名会被统一转换为小写形式，即 ID 最终会变成 id。

因为所有特性都是属性，所以直接给属性赋值可以设置特性的值

```javascript
div.id = 'someOtherId';
div.align = 'left';
```

不过，像下面这样为DOM元素添加一个自定义的属性，该属性不会自动成为元素的特性。

```javascript
div.mycolor = 'red';
console.log(div.getAttribute('mycolor')); // null(IE除外)
```

**removeAttribute()**

调用 `removeAttribute()` 方法可清除特性的值，同时会从元素中完全删除特性

```javascript
div.removeAttribute('class');
```

### attributes 属性

Element类型是使用 `attributes` 属性的唯一一个DOM节点类型。`attributes`属性中包含一个NamedNodeMap，与NodeList类似，也是一个“动态”的集合。元素的每一个特性都由一个Attr节点表示，每个节点都保存在NamedNodeMap对象中。NamedNodeMap对象有下列方法：

 - getNamedItem(name)：返回nodeName属性等于name的节点
 - removeNamedItem(name)：从列表中移除nodeName属性等于name的节点
 - setNamedItem(node)：向列表中添加节点，以节点的nodeName属性为索引
 - item(pos)：返回位于数字pos位置处的节点

attributes属性中包含一系列节点，每个节点的 nodeName 就是特性的名称，而节点的 nodeValue 就是特性的值。要取得元素的 id 特性，可以使用以下代码

```javascript
var id = element.attributes.getNamedItem('id').nodeValue;

// 方括号语法节点访问
var id = element.attributes['id'].nodeValue;
```

### 创建元素

使用 `document.createElement()` 方法可以创建元素。这个方法只接受一个参数，即要创建元素的标签名。这个标签名在HTML文档中不区分大小写，而在XML（包括HTML）文档中，则是区分大小写的。

```javascript
var div = document.createElement('div');
```

在使用 `createElement()` 方法创建新元素的同时，也为新元素设置了 ownDocument 属性。此时，还可以操作元素的特性，为它添加更多子节点，以及执行其他操作。

```javascript
div.id = 'myNewDiv';
div.className = 'box';
```

在新元素上设置这些特性知识给它们赋予了相应的信息。由于新元素尚未被添加到文档树中，因此设置这些特性不会影响浏览器的显示。要把新元素添加到文档树，可以使用 `appendChild()`、`insertBefore()`、`replaceChild()` 方法。下面的代码会把新创建的元素添加到文档的`<body>`元素中。

```javascript
document.body.appendChild(div);
```

### 元素的子节点

元素可以有任意数目的子节点和后代节点，因为元素可以是其他元素的子节点。元素的 `childNodes` 属性中包含了它的所有子节点，这些子节点有可能是元素、文本节点、注释或处理指令。不同浏览器在看待这些节点方面存在显著的不同。

```html
<ul id='myList'>
    <li>Item 1</li>
    <li>Item 2</li>
    <li>Item 3</li>
</ul>
```

 - IE解释：`<ul>`元素会有3个子节点，分别是3个`<li>`元素
 - 其他浏览器：`<ul>`元素都会有7个元素，包括3个`<li>`元素和4个文本节点（表示`<li>`元素之间的空白符）。如果像下面这样将元素的空白符删除，呢么所有浏览器都会返回相同数目的子节点。

```html
<ul id='myList'><li>Item 1</li><li>Item 2</li><li>Item 3</li></ul>
```

对于这段代码，`<ul>`元素在任何浏览器中都会包含3个子节点。如果需要通过 `childNodes` 属性遍历子节点，那么一定不要忘记浏览器间的这一差别。这意味着在执行某项操作以前，通常都要先检查一下 `nodeType` 属性

```javascript
for (var i=0, len = element.childNodes.length;i < len;i++){
    if (element.childNodes[i].nodeType == 1){
        // do something
    }
}
```

这个例子会循环遍历特定元素的每一个子节点，然后只在子节点的 `nodeType` 等于1（表示是元素节点）的情况下，才会执行某些操作。

**获取子节点或后代节点 getElementByTagName()**

在通过元素调用这个方法时，除了搜索起点是当前元素之外，其他方面都跟通过 document 调用这个方法相同，因此结果只会返回当前元素的后代。例如，要想取得前面 `<ul>`元素中包含的所有 `<li>` 元素，可以使用下列代码。

```javascript
var ul = document.getElementById('myList');
var items = ul.getElemntByTagName('li');
```

## Text 类型

文本节点由 Text 类型表示，包含的是可以照字面解释的纯文本内容。纯文本中可以包含转义后的 HTML字符，但不能包含 HTML 代码。

**节点特征**

 - nodeType 的值为3
 - nodeName 的值为 `'#text'`
 - nodeValue 的值为节点所包含的文本
 - parentNode 是一个Element
 - 不支持（没有）子节点

可以通过 nodeValue 属性或 data 属性访问 Text 节点中包含的文本，这两个属性中包含的值相同。对 nodeValue 的修改也会通过 data 反映出来，反之亦然。使用下列方法可以操作节点中的文本。

- appendData(text)：将 text 添加到节点的末尾
- deleteData(offset, count)：从 offset 指定的位置开始删除 count 个字符
- insertData(offset, text)：在 offset 指定的位置插入 text
- replaceData(offset, count, text)：用 text 替换从 offset 指定的位置开始到offset + count 为止处的文本
- splitText(offset)：从 offset 指定的位置将当前文本节点分成两个文本节点
- sustringData(offset, count)：提取从 offset 指定的位置开始到 offset + count 为止处的字符串

```html
<!-- 没有内容，也就没有文本节点 -->
<div></div>

<!-- 有空格，因而有一个文本节点 -->
<div></div>

<!-- 有内容，因而有一个文本节点 -->
<div>Hello World!</div>
```

```javascript
var textNode = div.firstChild; // 或者div.childNodes[0]

// 在取得了文本节点的饮用后，就可以像下面这样来修改它了
div.firstChild.nodeValue = 'Some other message';
```

如果这个文本节点当前存在于文档树中，那么修改文本节点的结果就会立即得到反映。另外，在修改文本节点时还要注意，此时的字符串会经过HTML编码。换句话说，小于号、大于号或引号都会像下面的例子一样被转义。

```javascript
// 输出结果是"some &lt;strong&gt;other&lt;/strong&gt; message"
div.firstChild.nodeValue = 'Some <strong>other</strong> message';
```

### 创建文本节点

```javascript
var textNode = document.createTextNode('<strong>Hello</strong> world!');
```

在创建新文本节点的同时，也会为其设置 ownerDocument 属性。不过，除非把新节点添加到文档树中已经存在的节点中，否则我们不会在浏览器窗口中看到新节点。下面的代码会创建一个 `<div>` 元素并向其中添加一条信息。

```javascript
var element = document.createElement('div');
element.className = 'message';

var textNode = document.createTextNode('Hello world!');
element.appendChild(textNode);
document.body.appendChild(element);
```

### 规范化文本节点

```javascript
var element = document.createElement('div');
element.className = 'message';

var textNode = document.createTextNode('Hello world!');
element.appendChild(textNode);

var anotherTextNode = document.createTextNode('Yippee!');
element.appendChild(anotherTextNode);

document.body.appendChild(element);

alert(element.childNodes.length); // 2

element.normalize();
alert(element.childNodes.length); // 1
alert(element.firstChild.nodeValue); // 'Hello world!Yippee!'
```

浏览器在解析文档时永远不会创建相邻的文本节点。这种那个情况只会作为执行DOM操作的结果出现。

### 分割文本节点

Text 类型提供了一个作用与 normalize() 相反的方法： splitText()。这个方法会将一个文本节点分成两个文本节点，即按照指定的位置分割 nodeValue 值。原来的文本节点将包含从开始到指定位置之前的内容，新文本节点将包含剩下的文本。这个方法会返回一个新文本节点，该节点与原节点的 parentNode 相同。

```javascript
var element = document.createElement('div');
element.className = 'message';

var textNode = document.createTextNode('Hello world!');
element.appendChild(textNode);

document.body.appendChild(element);

var newNode = element.firstChild.splitText(5);
alert(element.firstChild.nodeValue); // 'Hello'
alert(newNode.nodeValue); // 'world'
alert(element.childNodes.length); // 2
```

## Comment 类型

## CDATASection 类型

## DocumentType 类型

## DocumentFragment 类型

## Attr类型

  [1]: https://segmentfault.com/img/bVQyZd?w=1273&h=526/view
  [2]: https://segmentfault.com/img/bVQzLS?w=1274&h=547