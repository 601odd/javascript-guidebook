# HTTPS 协议

超文本传输安全协议（Hyper Text Transfer Protocol over Secure Socket Layer，HTTPS），是一种通过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 <span style="font-weight:bold;color:red">SSL / TLS</span> 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。

```js
HTTPS = HTTP + SSL（加密 + 认证 + 完整性保护）
```

HTTP 协议采用明文传输信息，存在信息窃听、信息篡改和信息劫持的风险，而协议 SSL / TLS 具有**身份验证**、**信息加密**和**完整性校验**的功能，可以避免此类问题发生。

SSL / TLS 全称安全传输层协议 Transport Layer Security，是介于 TCP 和 HTTP 之间的一层安全协议，不影响原有的 TCP 协议和 HTTP 协议，所以使用 HTTPS 基本上不需要对 HTTP 页面进行太多的改造。

## 安全问题

使用 HTTP 协议通信存在的问题：

* **窃听**：通信内容不经加密有可能<span style="font-weight:bold;color:red">被第三方捕获</span>
* **伪造**：第三方拦截通信内容，并<span style="font-weight:bold;color:red">伪装成发送方</span>向接收方发送通信内容
* **否认**：发送方将<span style="font-weight:bold;color:red">恶意数据</span>发送给接受方并否认这些数据是它发送的

### 窃听

![窃听](../images/8/60d45e59-0575-49ce-a090-159bcc7abba6.jpg)

### 伪造

![伪造](../images/8/27c3d2be-b78c-41df-be68-e51577704d6d.jpg)

### 否认

![否认](../images/8/cad6277c-47f2-4416-872a-801cbb592427.jpg)

## 解决方案

对通信内容进行加密的解决方案：

* **对称加密**：使用相同密钥加密/解密，但是钥匙交付问题无法解决
* **非对称加密**：公钥加密数据，私钥解密数据，但是加密/解密消耗时间较多
* **混合加密**：公钥加密密钥，密钥加密数据，私钥解密密钥，密钥解密数据（非对称传送密钥，密钥传送数据）。解决非对称加密效率问题
* **中间人攻击**：秘密替换公钥窃取数据，源于服务端无法确认客户端公钥是否合法
* **消息鉴别码**：`MAC` 密钥和密文组成的字符串的哈希值。能够解决 `伪造` 问题，但无法解决 `否认` 问题
* **数字签名**：服务端创建数字签名，而客户端只验证签名是否争取。解决 `否认` 问题
* **数字证书**：由权威机构背书创建证书，保证公钥不被篡改。解决 `中间人攻击` 问题

### 对称加密

![对称加密](../images/8/ee4b63b7-5d4d-4065-94f5-88d42ee0370c.jpg)

**对称密钥加密**一个很重要的特点就是使用相同的密钥进行加密和解密

![对称密钥交付问题](../images/8/33a9c0e1-d278-4f83-8870-09898a5ddebe.jpg)

假设 B 是没有解密钥匙，所以 A 需要通过互联网将钥匙发送给 B。

但是 X 也有可能看到并获取到这个钥匙，因此，X 也可以通过这个钥匙来解密密文。

上面这个场景就会引出一个新问题，这个问题被称为**钥匙交付问题**，那怎么解决这个问题？

### 非对称加密

为了解决上面的**钥匙交付问题**，我们这里引入一个新的方法 —— **非对称加密**

* 用于加密的密钥被称为**公钥**，用于解密的密钥被称为**私钥**
* 跟**对称加密**相比，公开密钥加密往往**需要更多的时间**用于加密和解密

**非对称加密过程**

接收方 B 创建一个公钥和一个私钥，公钥被发送给 A。

![非对称加密过程-创建](../images/8/eb922750-88ce-48cd-bcf9-1589b19124aa.jpg)

* A 使用从 B 收到的公钥加密数据，将密文发送给 B
* B 使用私钥解密从 A 接收到的密文，得到原始数据

![非对称加密过程-传输](../images/8/baf4b7bc-b9b7-40a7-a6fd-4d97b8e79271.jpg)

在这个过程中：

* 密文和公钥也可能被恶意第三方 X 截获
* 但是私钥是 B 保存的，X 无法获取到，自然没有办法解密密文
* 这样就很好的解决了**钥匙交付问题**

**公开密钥加密的问题**

1. 加密和解密都需要耗费时间，有一种叫**混合加密**的方法可以解决这个问题
2. 公开密钥的可靠性

### 混合加密

![混合加密](../images/8/466e4eed-22cf-40e0-9758-b9ed52c507f5.jpg)

混合密钥加密分为两个步骤：

* 通过公开密钥加密传递密钥
* 通过速度更快的对称密钥加密方法传递数据

### 中间人攻击

为了更好地理解公开密钥加密的可靠性问题，我们回到传递公钥的场景。

![中间人攻击](../images/8/79dccb40-6030-4e85-a1d5-d2dd6ab32600.jpg)

A 拿到的其实是 X 发送给他的伪造公钥，但是 A 无法察觉。

![](../images/8/36e552e6-64f9-46c2-b0e1-e15016f674b7.jpg)

最后，X 用他自己的密钥加密响应数据，并发送给 A，就这样，虽然 A、B 双方能顺利完成通信，但是恶意的第三方 X 能看到解密后的请求数据和响应数据，而 A、B 双方则毫不知情。
这种通过秘密替换公钥窃取数据的方法被称为**中间人攻击**，问题的根源在于 A 无法确认他们收到的公钥是否由 B 方创建。怎么避免中间人攻击呢？我们放到**数字证书**那节再探讨，接下来再讲解一点前置知识。

### 消息鉴别码

消息鉴别码在英文中被称为 MAC，MAC 可以理解为**密钥**和**密文**组成的字符串的**哈希值**。


![消息鉴别码](../images/8/2c3f025f-b245-4606-b7c4-e097d6031f36.jpg)

消息鉴别码虽然可以解决<span style="font-weight:bold;color:red">伪造</span>问题，但是仍然无法避免**否认**问题。

### 数字签名

为了解决这个<span style="font-weight:bold;color:red">否认</span>问题，我们接下来看看**数字签名**方法。

![数字签名](../images/8/d04409b8-39e2-4b3d-a519-3eb09aae3b38.jpg)

### 数字证书

虽然上面的方法已经能避免窃听、伪造、否认等问题，但是现在还是没办法避免**中间人攻击**，因为我们还是没办法验证公钥的所有者，因此我们需要<span style="font-weight:bold;color:red">数字证书</span>系统来验证公钥的所有者。

接下来，先看看数字证书申请的过程，我们将数字证书认证机构（Certificate Authority）称之为 CA。

**数字证书申请过程：**

1. 服务器方向第三方机构 CA **提交公钥**、**组织信息**、**个人信息（域名）**等信息并申请认证

2. CA 通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法、是否拥有域名的所有权等

3. 如信息审核通过，CA 会向申请者签发认证文件证书。证书包含以下信息：**申请者公钥**、**申请者的组织**和**个人信息**、**签发机构 CA 的信息**、**有效时间**、**证书序列号**等信息的明文，同时包含**数字签名**。数字签名通过**散列函数**计算公开的明文信息的**信息摘要**，然后，采用 CA 提供的私钥对信息摘要进行加密，加密后的信息摘要即为**数字签名**

![数字证书](../images/8/f76e7ce9-5b24-499b-bbcd-0eaeb8767aff.jpg)

现在 B 已经申请到一个数字证书了，那么怎么使用数字证书来检验公钥 PB 是属于 B 呢。

**数字证书校验流程：**

1. 客户端向服务端发送请求时，服务端返回数字证书文件
2. 客户端读取证书中的相关的明文信息，采用与加密时相同的**散列函数**计算得到信息摘要，然后利用内置客户端中的受信任的 CA 公钥解密数字签名，对比证书的信息摘要
   * 如果一致，则可以确认证书的合法性，即公钥合法
   * 如果不一致，则可以确认证书为非法，即公钥非法
   * 如果 CA 不被信任，则找不到对应 CA 证书，证书也会被判定为非法，即公钥非法

3. 客户端验证证书相关的域名信息、有效时间等信息

![数字证书](../images/8/b1b45e86-c2a7-4ce3-b14a-c1950e0fea95.jpg)

现在可以验证 PB 是属于 B 的，但是怎么验证 PC 是属于受信任的 CA 的呢。

![数字证书](../images/8/a546a6ee-4486-4cba-9d22-c166aecb6c71.jpg)

事实上，认证机构形成一个树形结构，高级别的权威机构为较低级别的机构创建证书，那就是说，如果要验证的话，就是一级一级向上认证，信任链条的最终是 Root CA，他采用自签名，对他的签名是无条件的信任。

![数字证书](../images/8/5023fcc0-62f1-4232-b06c-85fb2688f31c.jpg)

## 工作流程

HTTPS 在传输数据之前需要客户端（浏览器）与服务端之间进行一次握手，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL 协议使用**非对称加密**、**对称加密**以及 **HASH 算法**确保信息通信的安全。

![HTTPS Workflow](../images/8/18824375-da7a-48b8-8a0a-74123f2d6dc0.jpg)

**具体流程：**

1. **客户端发起 HTTPS 请求**：客户端（浏览器）将支持的一套加密规则发送给服务端

2. **服务端配置并传送证书**：服务端选用一组加密算法与 HASH 算法，并将自己的身份信息以证书的形式发回给客户端。证书包含**网站信息**、**加密公钥**，以及**经证书的颁发机构的私钥加密产生的数字签名**等信息

3. **客户端解析证书**：客户端获得网站数字证书并进行相关验证
   
   * 客户端先读取数字证书中相关的明文信息，采用相同的散列函数计算得到信息摘要，然后利用内置在客户端中的对应的 CA 的公钥解密数字签名数据，并与数字证书的摘要进行对比
     * 如果一致，则证书合法，即公钥合法（如果证书受信任，则客户端地址栏会显示小锁头）
     * 如果不一致，则证书非法，即公钥非法（如果证书不受信任，则会提示用户证书存在问题）
   
   * 如果证书受信任，客户端会生成一串随机数的密钥（即**消息鉴别码**：即用于终端数据交互的<span style="font-weight:bold;color:red">对称密钥</span>），并用证书中提供的公钥加密密钥
   * **传送加密信息**：使用约定好的 HASH 算法计算握手信息，并使用**对称密钥**对消息进行加密，最后将之前生成的所有信息发送给服务端
   
4. **服务端解密信息**：服务端接收客户端发来的数据之后的处理程序

   * 使用私钥将信息解密取出密钥，使用密钥解密客户端发来的握手信息，并验证 HASH 是否与浏览器发来的一致
   * **传输加密后的信息**：使用密钥加密一段握手消息，发送给客户端

5. 浏览器解密并计算握手信息的 Hash，如果与服务端发来的 Hash 一致，此时握手过程结束，之后所有的通信数据将由之前客户端生成的对称密钥并利用堆成加密算法进行加密

这里客户端与服务端互相发送加密的握手消息并验证，目的是为了保证双方都获得了一致的密码，并且可以正常的加密解密数据，为后续真正数据的传输做一次测试。

### 散列函数

常见的散列函数 Hash 算法：[MD5](https://zh.wikipedia.org/wiki/MD5)、[SHA1](https://zh.wikipedia.org/wiki/SHA-1)、[SHA256](https://zh.wikipedia.org/wiki/SHA%E5%AE%B6%E6%97%8F)

散列函数特点是函数单向不可逆转、对输入非常敏感、输出长度固定，针对数据的任何修改都会改变散列函数的结果，用于**防止信息篡改**并**验证数据的完整性**。

在信息传递过程中，散列函数不能单独实现信息信息防篡改，因为**明文传输**，中间人可以修改信息之后重新计算信息摘要，因此需要对传输的信息以及信息摘要进行加密。

### 对称加密

常见的对称加密算法：[AES-CBC](https://zh.wikipedia.org/wiki/AES指令集)、[DES](https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E5%8A%A0%E5%AF%86%E6%A8%99%E6%BA%96)、[3DES](https://zh.wikipedia.org/wiki/3DES)、[RC4](https://zh.wikipedia.org/wiki/RC4)

相同的密钥可以用于信息的加密和解密，掌握密钥才能获取信息，能够防止信息窃听，通信方式是 1 对 1。

对称加密的优势是信息传输 1 对 1，需要共享相同的密码，密码的安全是保证信息安全的基础，服务器和 N 个客户端通信，需要维持 N 个密码记录，且缺少修改密码的机制。

### 非对称加密

常见非对称加密算法：[RSA](https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95)、DSA / DSS

密钥成对出现，一般称为公钥（公开）和私钥（保密），公钥加密的信息只能私钥解开，私钥加密的信息只能公钥解开。因此掌握公钥的不同客户端之间不能互相解密信息，只能和掌握私钥的服务器进行加密通信，服务器可以实现 1 对 N 的通信，客户端也可以用来验证掌握私钥的服务器身份。

非对称加密的特点是 1 对多，服务器只需要维持一个私钥就能够和多个客户端进行加密通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密速度慢。

## 通信协议对比

**HTTP 协议和 HTTPS 协议的区别**

|       | 传输方式       | 端口 | 连接   | 特殊             |
| ----- | -------------- | ---- | ------ | ---------------- |
| HTTP  | 明文传输       | 80   | -      | -                |
| HTTPS | SSL + TLS 加密 | 443  | 无状态 | 需要 CA 申请证书 |

**HTTPS 主要作用**

* 对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全
* 对网站服务器进行真实身份认证

---

**参考资料：**

* [📝 一个故事讲完 HTTPS](https://mp.weixin.qq.com/s/StqqafHePlBkWAPQZg3NrA)
* [📝 图解 HTTPS 协议](https://juejin.im/entry/56ce90edefa631df62c21f8d)
* [📝 完全图解 HTTPS](https://juejin.im/post/5c441073e51d455226654d60)
* [📝 HTTP 和 HTTPS 详解](https://juejin.im/post/5af557a3f265da0b9265a498)