## 渲染树构建

在 DOM 树构建的同时，浏览器还会构建另一个树结构：渲染树（Rendering Tree）。这是由可视化元素按照其显示顺序而组成的树，也是文档的可视化表示。它的作用是让您按照正确的顺序绘制内容。

渲染树的节点（渲染器），在 Gecko 内核的浏览器中称为框架（Frame），而在 Webkit 内核的浏览器中称为渲染器或渲染对象（Renderer）。渲染器是在文档解析和创建 DOM 节点后创建的，会计算 DOM 节点的样式信息。

### 渲染树与DOM树关系

- 渲染对象是和 DOM 元素相对应，但这种对应关系并非一一对应，**非可视化**的 DOM 元素不会被插入渲染树中。
  - 例如， `<head>` 标签以及里面的内容，以及 `display:none` 的元素也会被去除，但是 `visibility` 属性值为 `hidden` 的元素仍会显示

- 部分 DOM 元素可对应多个可视化对象。它们往往是具有复杂结构的元素，无法用单一的矩形来描述。
  - 例如， `select` 元素有 3 个渲染器：一个用于显示区域，一个用于下拉列表框，还有一个用于按钮。如果由于宽度不够，文本无法在一行中显示而分为多行，那么新的行也会作为新的呈现器而添加。
  - 另一个关于多渲染器的例子是格式无效的 HTML。根据 CSS 规范，行内元素只能仅包含块状元素或行内元素中的一种。如果出现了混合内容，则应创建匿名的块状渲染对象，以包裹行内元素。所以我们平时的 `inline-block` 可以设置宽高。
- 部分渲染对象对应于 DOM 节点，但树中所在的位置与 DOM 节点不同。
  - 例如，浮动定位和绝对定位的元素处于正常的文本流之外，在两棵树上的位置不同，渲染树上标识出真实的结构，并用一个占位结构标识出它们原来的位置。

![渲染树及对应DOM树](../../images/5/456c7ab1-0dc8-4975-822e-66eb1739b474.png)

### 构建渲染树的流程

在 Firefox 中，系统会针对 DOM 更新注册展示层，作为侦听器。展示层将框架创建工作委托给 FrameConstructor，由该构造器解析样式（请参阅[样式计算](#样式计算)）并创建框架。

在 WebKit 中，解析样式和创建呈现器的过程称为“附加”。每个 DOM 节点都有一个 `attach` 方法。附加是同步进行的，将节点插入 DOM 树需要调用新的节点 `attach` 方法。

处理 html 和 body 标记就会构建渲染树根节点。这个根节点呈现对象对应于 CSS 规范中所说的容器 block，这是最上层的 block，包含了其他所有 block。它的尺寸就是视口，即浏览器窗口显示区域的尺寸。Firefox 称之为 ViewPortFrame，而 WebKit 称之为 RenderView。这就是文档所指向的呈现对象。呈现树的其余部分以 DOM 树节点插入的形式来构建。

请参阅[关于处理模型的 CSS2 规范](http://www.w3.org/TR/CSS21/intro.html#processing-model)。

 ### 样式计算

构建渲染树之前，需要计算每一个渲染对象的可视化属性。这是通过计算每个元素的样式属性来完成的。

样式包括来自各种来源的样式表、行内样式元素和 HTML 中的可视化属性。其中后者经过转化以匹配 CSS 样式属性。

样式表的来源包括浏览器的默认样式表、由网页作者提供的样式表以及由浏览器用户提供的用户样式表（浏览器允许您定义自己喜欢的样式。以 Firefox 为例，用户可以将自己喜欢的样式表放在 Firefox Profile 文件夹下）。

样式计算存在以下难点：

1. 样式数据是一个超大的结构，存储了无数的样式属性，这可能造成内存问题。
2. 如果不进行优化，为每一个元素查找匹配的规则会造成性能问题。要为每一个元素遍历整个规则列表来寻找匹配规则，这是一项浩大的工程。选择器会具有很复杂的结构，这就会导致某个匹配过程一开始看起来很可能是正确的，但最终发现其实是徒劳的，必须尝试其他匹配路径。
3. 应用规则涉及到相当复杂的层叠规则（用于定义这些规则的层次）

#### 共享样式数据

WebKit 节点会引用样式对象 (RenderStyle)。这些对象在某些情况下可以由不同节点共享。这些节点是同级关系，并且：

1. 这些元素必须处于相同的鼠标状态（例如，不允许其中一个是 `:hover` 状态，而另一个不是）
2. 任何元素都没有 id
3. 标记名称应匹配
4. 类属性应匹配
5. 映射属性的集合必须是完全相同的
6. 链接状态必须匹配
7. 焦点状态必须匹配
8. 任何元素都不应受属性选择器的影响，这里所说的“影响”是指在选择器中的任何位置有任何使用了属性选择器的选择器匹配
9. 元素中不能有任何 `inline` 样式属性
10. 不能使用任何同级选择器。WebCore 在遇到任何同级选择器时，只会引发一个全局开关，并停用整个文档的样式共享（如果存在）。这包括 `+` 选择器以及 `:first-child` 和 `:last-child` 等选择器。

#### Firefox规则树

为了简化样式计算，Firefox 还采用了另外两种树：**规则树**和**样式上下文树**。WebKit 也有样式对象，但它们不是保存在类似样式上下文树这样的树结构中，只是由 DOM 节点指向此类对象的相关样式。

![Firefox样式上下文树](../../images/5/247e8b92-bea2-494b-84d4-1e0c489876c8.png)

样式上下文包含端值。要计算出这些值，应按照正确顺序应用所有匹配规则，并将其从逻辑值转化为具体的值。例如，如果逻辑值是屏幕大小的百分比，则需要换算成绝对的单位。规则树的点子真的很巧妙，它使得节点之间可以共享这些值，以避免重复计算，还可以节约空间。

所有匹配的规则都存储在树中。路径中的底层节点拥有较高的优先级。规则树包含了所有已知规则匹配的路径。规则的存储是延迟进行的。规则树不会在开始的时候就为所有的节点进行计算，而是只有当某个节点样式需要进行计算时，才会向规则树添加计算的路径。

这个想法相当于将规则树路径视为词典中的单词。如果我们已经计算出如下的规则树：

![规则树](../../images/5/8ff33738-469a-455e-b27f-cb9a8ea5896c.png)

假设我们需要为内容树中的另一个元素匹配规则，并且找到匹配路径是 B-E-I（按照此顺序）。由于我们在树中已经计算出了路径 A-B-E-I-L，因此就已经有了此路径，这就减少了现在所需的工作量。

##### 结构划分

样式上下文可分割成多个结构。这些结构体包含了特定类别（如 `border` 或 `color`）的样式信息。结构中的属性都是继承的或非继承的。继承属性如果未由元素定义，则继承自其父代。非继承属性（也称为“重置”属性）如果未进行定义，则使用默认值。

规则树通过缓存整个结构（包含计算出的端值）为我们提供帮助。这一想法假定底层节点没有提供结构的定义，则可使用上层节点中的缓存结构。

##### 使用规则树计算样式上下文

在计算某个特定元素的样式上下文时，我们首先计算规则树中的对应路径，或者使用现有的路径。然后我们沿此路径应用规则，在新的样式上下文中填充结构。我们从路径中拥有最高优先级的底层节点（通常也是最特殊的选择器）开始，并向上遍历规则树，直到结构填充完毕。如果该规则节点对于此结构没有任何规范，那么我们可以实现更好的优化：寻找路径更上层的节点，找到后指定完整的规范并指向相关节点即可。这是最好的优化方法，因为整个结构都能共享。这可以减少端值的计算量并节约内存。 
如果我们找到了部分定义，就会向上遍历规则树，直到结构填充完毕。

如果我们找不到结构的任何定义，那么假如该结构是“继承”类型，我们会在**上下文树**中指向父代的结构，这样也可以共享结构。如果是 reset 类型的结构，则会使用默认值。

如果最特殊的节点确实添加了值，那么我们需要另外进行一些计算，以便将这些值转化成实际值。然后我们将结果缓存在树节点中，供子代使用。

如果某个元素与其同级元素都指向同一个树节点，那么它们就可以共享**整个样式上下文**。

让我们来看一个例子，假设我们有如下 HTML 代码：

```html
<html>
  <body>
    <div class="err" id="div1">
      <p>
        this is a <span class="big"> big error </span>
        this is also a
        <span class="big"> very  big  error</span> error
      </p>
    </div>
    <div class="err" id="div2">another error</div>
  </body>
</html>
```

还有如下规则：

```css
1. div {margin: 5px;color: black}
2. .err {color: red}
3. .big {margin-top: 3px}
4. div span {margin-bottom: 4px}
5. #div1 {color: blue}
6. #div2 {color: green}
```

为了简便起见，我们只需要填充两个结构：`color` 结构和 `margin` 结构。`color` 结构只包含一个成员（即 `color`），而 `margin` 结构包含四条边。  形成的规则树如下图所示（节点的标记方式为“节点名 : 指向的规则序号”）：

![规则树](../../images/5/7d9aea6b-e0dd-4ba8-8710-84301e2debef.png)

上下文树如下图所示（节点名：指向的规则节点）：

![上下文树](../../images/5/e8cfa390-4fb9-4e69-b05f-2feb2cf1ccac.png)

假设我们解析 HTML 时遇到了第二个 `<div>` 标记，我们需要为此节点创建样式上下文，并填充其样式结构。 
经过规则匹配，我们发现该 `<div>` 的匹配规则是第 1、2 和 6 条。这意味着规则树中已有一条路径可供我们的元素使用，我们只需要再为其添加一个节点以匹配第 6 条规则（规则树中的 F 节点）。 
我们将创建样式上下文并将其放入上下文树中。新的样式上下文将指向规则树中的 F 节点。

现在我们需要填充样式结构。首先要填充的是 `margin` 结构。由于最后的规则节点（F）并没有添加到 `margin` 结构，我们需要上溯规则树，直至找到在先前节点插入中计算过的缓存结构，然后使用该结构。我们会在指定 `margin` 规则的最上层节点（即 B 节点）上找到该结构。

我们已经有了 `color` 结构的定义，因此不能使用缓存的结构。由于 `color` 有一个属性，我们无需上溯规则树以填充其他属性。我们将计算端值（将字符串转化为 RGB 等）并在此节点上缓存经过计算的结构。

第二个 `<span>` 元素处理起来更加简单。我们将匹配规则，最终发现它和之前的 `span` 一样指向规则 G。由于我们找到了指向同一节点的同级，就可以共享整个样式上下文了，只需指向之前 `span` 的上下文即可。

对于包含了继承自父代的规则的结构，缓存是在上下文树中进行的（事实上 `color` 属性是继承的，但是 Firefox 将其视为 reset 属性，并缓存到规则树上）。 
例如，如果我们在某个段落中添加 `font` 规则：

```css
p {
    font-family:Verdana;
    font size:10px;
    font-weight:bold;
}
```

那么，该段落元素作为上下文树中的 `div` 的子代，就会共享与其父代相同的 `font` 结构（前提是该段落没有指定 `font` 规则）。

在 WebKit 中没有规则树，因此会对匹配的声明遍历 4 次。首先应用非重要高优先级的属性（由于作为其他属性的依据而应首先应用的属性，例如 `display`），接着是高优先级重要规则，然后是普通优先级非重要规则，最后是普通优先级重要规则。这意味着多次出现的属性会根据正确的层叠顺序进行解析。最后出现的最终生效。 

#### 对规则进行处理以简化匹配

样式规则来源：

- 外部样式表获样式元素中的 CSS 规则

```css
p {
    color: blue;
}
```

- 行内样式属性及类似内容

```html
<p style="color: blue" />
```

- HTML 可视化属性（映射到相关的样式规则）

```html
<p bgcolor="blue" />
```

后两种很容易和元素进行匹配，因为元素拥有样式属性，而且 HTML 属性可以使用元素作为键值进行映射。

样式表解析完毕后，系统会根据选择器将 CSS 规则添加到某个哈希表中。这些哈希表的选择器各不相同，包括 ID、类名称、标记名称等，还有一种通用哈希表，适合不属于上述类别的规则。如果选择器是 id，规则就会添加到 id 表中；如果选择器是类，规则就会添加到类表中，依此类推。

这种处理可以大大简化规则匹配。我们无需查看每一条声明，只要从哈希表中提取元素的相关规则即可。这种优化方法可排除掉95%以上规则，因此在匹配过程中根本就不用考虑这些规则。

我们以如下的样式规则为例：

```css
p.error {
    color: red;
}
#messageDiv {
    height: 50px;
}
div {
    margin: 5px;
}
```

第一条规则将插入类表，第二条将插入 id 表，而第三条将插入标记表。

```html
<p class="error">an error occurred</p>
<div id="messageDiv">this is a message</div>
```

我们首先会为 `p` 元素寻找匹配的规则。类表中有一个 `error` 键，在下面可以找到 `p.error` 的规则。`div` 元素在 `id` 表（键为 `id`）和标记表中有相关的规则。剩下的工作就是找出哪些根据键提取的规则是真正匹配的了。

例如，如果 `div` 的对应规则如下：

```css
table div {
    margin: 5px;
}
```

这条规则仍然会从标记表中提取出来，因为键是最右边的选择器，但这条规则并不匹配我们的 `div` 元素，因为 `div` 没有 `table` 祖先。

Webkit 和 Firefox 都进行了这一处理。

#### 以正确的层叠顺序应用规则

样式对象具有与每个可视化属性一一对应的属性（均为 CSS 属性但更为通用）。如果某个属性未由任何匹配规则所定义，那么部分属性就可由父代元素样式对象继承。其他属性具有默认值。

如果定义不止一个，就会出现问题，需要通过层叠顺序来解决。

##### 样式表的级联顺序

某个样式属性的声明可能会出现在多个样式表中，也可能在同一个样式表中出现多次。这意味着应用规则的顺序极为重要。这称为“层叠”顺序。根据 CSS2 规范，层叠的顺序为（优先级从低到高）：

1. 浏览器声明
2. 用户普通声明
3. 作者普通声明
4. 作者的 important 声明
5. 用户的 important 声明

浏览器声明是重要程度最低的，而用户只有将该声明标记为 `important` 时才会覆盖网页作者的声明。同等级别的声明将根据[特异性](#特异性)以及它们被定义时的顺序进行排序。HTML 可视化属性将被转换为匹配的 CSS 声明，它们被视为最低优先级的作者规则。

##### 特异性

选择器的特异性由 CSS2规范定义：

- 如果声明来自 `style` 属性，而不是带有选择器的规则，则记为1，否则记为0（=a）
- 记为选择器中 ID 属性的个数（=b）
- 记为选择器中其他属性和伪类的个数（=c）
- 记为选择器中元素名称和伪元素的个数（=d）

将四个数字按 a-b-c-d 这样连接起来（位于大数进位的数字系统中），构成特异性。

您使用的进取制取决于上述类别中的最高计数。

例如，如果 `a = 14` ，您可以使用十六进制。如果 `a = 17`，那么您需要使用十七进制；当然不太可能出现这种情况，除非是存在如下的选择器：`html body div div p ...`（在选择器中出现了 17 个标记，这样的可能性极低）。

**示例：**

```css
 *             {}  /* a=0 b=0 c=0 d=0 -> specificity = 0,0,0,0 */
 li            {}  /* a=0 b=0 c=0 d=1 -> specificity = 0,0,0,1 */
 li:first-line {}  /* a=0 b=0 c=0 d=2 -> specificity = 0,0,0,2 */
 ul li         {}  /* a=0 b=0 c=0 d=2 -> specificity = 0,0,0,2 */
 ul ol+li      {}  /* a=0 b=0 c=0 d=3 -> specificity = 0,0,0,3 */
 h1 + *[rel=up]{}  /* a=0 b=0 c=1 d=1 -> specificity = 0,0,1,1 */
 ul ol li.red  {}  /* a=0 b=0 c=1 d=3 -> specificity = 0,0,1,3 */
 li.red.level  {}  /* a=0 b=0 c=2 d=1 -> specificity = 0,0,2,1 */
 #x34y         {}  /* a=0 b=1 c=0 d=0 -> specificity = 0,1,0,0 */
 style=""          /* a=1 b=0 c=0 d=0 -> specificity = 1,0,0,0 */
```

##### 规则排序

找到匹配的规则之后，应根据级联顺序将其排序。WebKit 对于较小的列表会使用冒泡排序，而对较大的列表则使用归并排序。对于以下规则，WebKit 通过替换 `>` 运算符来实现排序：

```c++
static bool operator >(CSSRuleData& r1, CSSRuleData& r2){
    int spec1 = r1.selector()->specificity();
    int spec2 = r2.selector()->specificity();
    return (spec1 == spec2) : r1.position() > r2.position() : spec1 > spec2;
}
```

### 渐进式处理

WebKit 使用一个标记来表示是否所有的顶级样式表（包括 `@imports`）均已加载完毕。如果在附加过程中尚未完全加载样式，则使用占位符在文档中进行标注，一旦样式表加载完毕后再重新进行计算。

---

参考资料：

-  [掘金：浏览器原理](https://juejin.im/post/5b0a6f1af265da0ddb63ecd9#heading-4)
-  [浏览器的工作原理：新式网络浏览器幕后揭秘](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#Style_Computation)

 

 