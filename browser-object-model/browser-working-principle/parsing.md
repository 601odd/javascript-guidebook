## 解析过程

- 获取请求文档的内容后，呈现引擎将开始解析 HTML 文档，并将各标记逐个转化成“内容树”上的 DOM 节点。
- 解析外部 CSS 以及 `<style>` 元素中的样式数据形成呈现树。呈现树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。呈现树构建完毕之后，进入“布局”处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。
- 解析 `<script>` 标签时，解析完毕马上执行，并且阻塞页面。
- 绘制，呈现引擎会遍历呈现树，由用户界面后端层将每个节点绘制出来。

### 词法、语法分析与编译

词法分析器将输入内容分解成一个个有效标记，解析器负责根据语言的语法规则分析文档的结构来构建解析树。词法分析器知道如何将无关的字符（空格、换行符等）分离出来，所以我们平时写一些空格也不会影响大局。

在语法分析的过程中，解析器会向词法分析器请求一个标记（就是前面分解出来的标记），并尝试将其与某条语法规则（比如标签要闭合、正确嵌套）进行匹配。如果发现了匹配规则，解析器会将一个对应于该标记的节点添加到解析树中，然后继续请求下一个标记。

如果没有规则可以匹配，解析器就会将标记存储到内部，并继续请求标记，直至找到可与所有内部存储的标记匹配的规则（如 `<div>` 多层嵌套的情况，这样子能找到 `<div>` 闭合部分）。如果找不到任何匹配规则，解析器就会引发一个异常。这意味着文档无效，包含语法错误。

解析器类型有两种：

- 自上而下解析器：从语法的高层结构出发，尝试从中找到匹配的结构。
- 自下而上解析器：从低层规则出发，将输入内容逐步转化为语法规则，直至满足高层规则。将扫描输入内容，找到匹配的规则后，将匹配的输入内容替换成规则。如此继续替换，直到输入内容的结尾。部分匹配的表达式保存在解析器的堆栈中。

编译：将源代码编译成机器代码，源代码先走完解析的过程形成成解析树，解析树被翻译成机器代码文档，完成编译的过程。

### DTD

特殊的是，恰好 HTML 不能用上面两种解析方法。有一种可以定义 HTML 的正规格式：DTD（Document Type Definition，文档类型定义），但它不是与上下文无关的语法，HTML 明显是和上下文关系紧密的。我们知道 HTML 是有点“随意”的，对于不闭合的或者不正确嵌套标签有可能不报错，并且尝试解释成正确的样子，具有一定的容错机性，因此可以达到简化网络开发的效果。另一方面，这使得它很难编写正式的语法。概括地说，HTML 无法很容易地通过常规解析器解析（因为它的语法不是与上下文无关的语法），所以采用了 DTD 格式。

### HTML解析

解析器解析 HTML 文档的解析树是由 DOM 元素和属性节点构成的树结构。它是 HTML 文档的对象表示，同时也是外部内容（例如 JavaScript）与 HTML 元素之间的 API，其根节点是 `document`。上面已经说到，不能使用常规的解析技术解释 HTML，浏览器就创建了自定义的解析器来解析 。对于 HTML/SVG/XHTML 这三种文档，Webkit 有三个 C++ 的类对应这三种文档，并产生一个 DOM Tree。解释 HTML 成 DOM 的过程，由两个阶段组成：**标记化**和**树构建**。

#### 标记化算法

```html
<html>
    <body>
        hi
    </body>
</html>
```

**The tokenization algorithm（标记化算法，亦称符号识别算法）**，该算法使用状态机来表示。每一个状态接收来自输入信息流的一个或多个字符，并根据这些字符更新下一个状态。当前的标记化状态和树结构状态会影响进入下一状态的决定。

- 初始状态：数据状态
- 遇到字符 `<`：标记打开状态（Tag open state）
- 遇到字符：创建起始标记，标记名称状态（Tag name state）
- 遇到 `>`：发送当前标记，在此期间接受到的每个字符都会附加到新的标记名称上，状态改回数据状态
- 遇到字符：创建并发送字符标记
- 再次遇到 `<`：回到标记打开状态（Tag open state）
- 遇到字符 `/`：创建闭合标签 token（End tag token），并改为标记名称状态（Tag name state），保持状态，直到接收 `>`，然后发送新的标记，回到数据状态

#### 树构建过程

在创建解析器的同时也会创建 document 对象。在树构建阶段，以 `<document>` 为根节点的 DOM 树也会不断进行修改，向其中添加各种元素。标记生成器发送的每个节点都会由树构建器进行处理。

树构建阶段的输入是一个来自标记化阶段的标记序列。

1. 第一个模式是“initial mode”。接收 `<html>` 标记后转为“before html”模式，并在这个模式下重新处理此标记。这样会创建一个 HTMLHtmlElement 元素，并将其附加到 `<document>` 根对象上。
2. 状态改为“before head”。此时我们接收 `<body>` 标记。由于容错性，就算我们的没 `<head>` 标签，系统也会隐式创建一个 HTMLHeadElement，并将其添加到树中。
3. 进入了“in head”模式，然后转入“after head”模式。系统对 `<body>` 标记进行重新处理，创建并插入 HTMLBodyElement，同时模式转变为“in body”。
4. 接收由“hi”字符串生成的一系列字符标记。接收第一个字符时会创建并插入文本节点，而其他字符也将附加到该节点。当然还有其他节点，比如属性节点、换行节点。我们实际场景还有外部资源以及其他各种各样的复杂标签嵌套和内容结构，不过原理都类似。对于中间这个过程，遇到外部资源如何处理，顺序是怎样的，后面再讲。
5. 接收 `</body>` 结束标记会触发“after body”模式。现在我们将接收 `</html>` 结束标记，然后进入“after after body”模式。接收到文件结束标记后，解析过程就此结束，DOM 树已经建立完毕（不是加载完毕，在 DOMContentLoaded 之前，`document.readyState = 'interactive'` ）。

![DOM树构建过程](../../Image/05/825ad83c-3a24-4ea1-aa2b-c99691d52e05.gif)

结束后，此时文档被标注为交互状态，浏览器开始解析那些 `<script>` 标签上带有“defer”脚本，也就是那些应在文档解析完成后才执行的脚本，文档状态将设置为完成，执行完毕触发 DOMContentLoaded 事件（当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，不会等待样式表、图像和 iframe 的完成加载）。

[🔍HTML5规范中的标记化和构建树的完整算法](https://www.w3.org/TR/html5/syntax.html#html-parser)

### CSS解析

解析 CSS 会产生 CSS 规则树，前面已经说到，HTML 不是与上下文无关的语法，而 CSS 和 JavaScript 是与上下文无关的语法，所以常规的解析方法都可以用。对于建立 CSS 规则树，是需要比照着 DOM 树来的。CSS 匹配 DOM 树主要是**从右到左**解析 CSS 选择器。解析 CSS 的顺序是 `浏览器的样式 -> 用户自定义的样式 -> 页面的link标签等引进来的样式 -> 写在style标签里面的内联样式`

样式表不会更改 DOM 树，因此没有必要等待样式表并停止文档解析。而脚本在文档解析阶段会请求样式信息时还没有加载和解析样式，脚本就会获得错误的回复。Firefox 在样式表加载和解析的过程中，会禁止所有脚本。而对于 WebKit 而言，仅当脚本尝试访问的样式属性可能受尚未加载的样式表影响时，它才会禁止该脚本。

### JavaScript解析

- 网络整个解析的过程是同步的，会暂停 DOM 的解析。解析器遇到 `<script>` 标记时立即解析并执行脚本。文档的解析将停止，直到脚本执行完毕。
- 如果脚本是外部的，那么解析过程会停止，直到从网络同步抓取资源完成后再继续。
- 目前浏览器的 `<script>` 标签是并行下载的，他们互相之间不会阻塞，但是会阻塞其他资源（图片）的下载

所以为了用户体验，后来有了 async 和 defer，将脚本标记为异步，不会阻塞其他线程解析和执行。标注为 “defer” 的 `<script>` 不会停止文档解析，而是等到解析结束才执行；标注为 “async” 只能引用外部脚本，下载完马上执行，而且不能保证加载顺序。

![JavaScript解析](../../Image/05/5c5584c0-2044-4c27-9af4-2704cfe30ab7.png)



脚本的预解析：在执行脚本时，其他线程会解析文档的其余部分，找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，从而提高总体速度。请注意，预解析器不会修改 DOM 树，而是将这项工作交由主解析器处理；预解析器只会解析外部资源（例如外部脚本、样式表和图片）的引用。

脚本主要是通过 DOM API 和 CSSOM API 来操作 DOM Tree 和 CSS Rule Tree。

另外，我们又可以想到一个问题，为什么 jsonp 能 response 一个类 eval 字符串就马上执行呢？其实也是因为普通的 `<script>` 标签解析完成就马上执行，我们在服务器那边大概是这样子返回：`res.end('callback('+data+')')`

整个过程，就是：动态创建 `<script>` 标签，`src` 为服务器的一个 GET 请求接口，遇到 `src` 当然马上请求服务器，然后服务器返回处理 data 的 callback 函数这样子的代码。其实，我们可以看作是前端发 GET 请求，服务端响应文档是 js 文件，而且这个文件只有一行代码：callback（data）。当然你可以写很多代码，不过一般没见过有人这么干。

### 总结

**解析 HTML 为 DOM 树：**

1. HTML 字节流解码变为字符流。根据不同编码方式，如 UTF-8 GBK 来解码。
2. 词法分析：将字符流解析为一个个词语。
3. 语法分析：通过不同标签，生成 Node 节点。
4. 构建 DOM 树：将 Node 节点组织成 DOM 树。

**解析 CSS 为 CSS 规则树，得到元素最匹配的样式：**

1. 经过词法分析和语法分析，生成一个个 CSS 规则。规则由选择器和一个 `key: value` 对组成的属性集合构成。
2. 进行规则匹配：根据元素信息，如 id、class、标签，通过不同优先级得到元素最匹配的 CSS 规则

---

参考资料：

- [掘金：浏览器原理](https://juejin.im/post/5b0a6f1af265da0ddb63ecd9)
- [前端必读：浏览器内部工作原理](https://www.cnblogs.com/wjlog/p/5744753.html#chapter8)
- [W3C DOM规范](https://www.w3.org/DOM/DOMTR)