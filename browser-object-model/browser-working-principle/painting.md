# 绘制

在绘制阶段，系统会遍历渲染树，并调用渲染器的 `paint` 方法，将渲染器的内容绘制成位图。

绘制工作是使用用户界面基础组件完成的。你所看见的一切都会触发 `paint`。包括拖动滚动条，鼠标选择中文字等这些完全不改变样式，只改变显示结果的动作都会触发 `paint`。

`paint` 的工作就是把文档中用户可见的那一部分展现给用户。`paint` 是把 `layout` 和样式计算的结果直接在浏览器视窗上绘制出来，它并不实现具体的元素计算，只是 `layout` 后面的那一步。

## 全局绘制和增量绘制

和布局一样，绘制也分为全局和增量两种。

在增量绘制中，部分渲染器发生了更改，但是不会影响整个树。更改后的渲染器将其在屏幕上对应的矩形区域设为无效，这导致 OS 将其视为一块 dirty 区域，并生成 `paint` 事件。OS 会很巧妙地将多个区域合并成一个。在 Chrome 浏览器中，情况要更复杂一些，因为 Chrome 浏览器的渲染器不在主进程上。Chrome 浏览器会在某种程度上模拟 OS 的行为。展示层会侦听这些事件，并将消息委托给呈现根节点。然后遍历渲染树，直到找到相关的呈现器，该呈现器会重新绘制自己（通常也包括其子代）。

## 绘制顺序

[CSS2 规范](http://www.w3.org/TR/CSS21/zindex.html) 定义了绘制流程的顺序。绘制的顺序其实就是元素进入 [堆栈样式上下文](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#stackingcontext) 的顺序。这些堆栈会从后往前绘制，因此这样的顺序会影响绘制。块呈现器的堆栈顺序如下：

1. 背景颜色（background-color）
2. 背景图片（background-image）
3. 边框（border）
4. 子代
5. 轮廓（outline）

在样式发生变化时，浏览器会尽可能做出最小的响应。因此，元素的颜色改变后，只会对该元素进行重绘。元素的位置改变后，只会对该元素及其子元素（可能还有同级元素）进行布局和重绘。添加 DOM 节点后，会对该节点进行布局和重绘。一些重大变化（例如增大 `<html>` 元素的字体）会导致缓存无效，使得整个渲染树都会进行重新布局和绘制。

