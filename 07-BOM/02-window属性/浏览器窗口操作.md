# 浏览器窗口操作

tags: 前端生存指南

## 与window相关的宽高属性

### window和document

**window对象**
 `window`对象表示浏览器中打开的窗口；`window`对象可以省略。例如 `alert()` 和 `window.alert()`

**document对象**
 `document`对象是`window`对象的一部分。那么`document.body`我们可以写成`window.document.body`；浏览器的HTML文档成为Document对象。

### window.location和document.location

- `window` 对象的 `location` 属性引用的是 `location` 对象，**表示该窗口中当前显示文档的URL**。
- `document` 的对象 `location` 属性也是 `location` 对象

```javascript
window.location ==== document.location; // true
```

### 与window相关的宽高(浏览器窗口属性)

与 `window` 相关的宽高有以下几个：

 1. `window.innerWidth`，浏览器网页窗口内部宽度（不包含开发者控制台）
 2. `window.innerHeight`，浏览器网页窗口内部高度（不包含标签栏、地址栏、书签栏和开发者控制台）
 3. `window.outWidth`，浏览器窗口外部宽度（包含开发者控制台）
 4. `window.outHeight`，浏览器窗口外部高度（包含标签栏、地址栏、书签栏和开发者控制台）

**调节浏览器窗口大小也会影响与window相关的宽高。**

### window.screen(用户屏幕信息)

挂跨在window下的宽高还有包含有关用户屏幕信息的 `window.screen`

 - `window.screen.width`
 - `window.screen.height`
 - `window.screen.availHeight`
 - `window.screen.availWidth`
 - `window.screenTop`
 - `window.screenLeft`



 **window相关宽高浏览器兼容问题**
 
 `innerHeight` 和 `outerHeight` 是不支持IE9以下版本的，而 `screen` 系列则不存在兼容问题

## 与document相关的宽高属性

### 与client相关的宽高

与client相关的宽高又有如下几个属性：

 - `document.body.clientWidth`
 - `document.body.clientHeight`
 - `document.body.clientLeft`
 - `document.body.clientTop`

**clientWidth和clientHeight**

 - `document.body.clientWidth` 元素宽度（可视内容区+内边距）
 - `document.body.clientHeight` 元素高度（可视内容区+内边距）

 
 该属性指的是**元素的可视部分宽度和高度**，即 `padding+content`
 
 如果没有滚动条，即为元素设定的高度和宽度。
 
 如果出现滚动条，滚动条会遮盖元素的宽高，那么该属性就是其本来宽高减去滚动条的宽高。
  
```html
<style>
body{
    border: 20px solid #000;
    margin: 10px;
    padding: 40px;
    background: #eee;
    height: 350px;
    width: 500px;
    overflow: scroll;
}
</style>
<script>
console.log(document.body.clientHeight);    // 430（padding*2+height）
console.log(document.body.clientWidth);     // 580（padding*2+width）
</script>
```

我们再看下面的代码

在 `div` 中添加文字，直到出现滚动条

```html
<style>
#mydiv{
    width: 200px;
    height: 200px;
    background: red;
    border: 1px solid #000;
    overflow: auto;
}
</style>
<script>
    const mydiv = document.getElementById('mydiv');
    console.log('mydiv.clientHeight=', mydiv.clientHeight); // 200
    console.log('mydiv.clientWidth=', mydiv.clientWidth); // 183（减去了滚动条的宽度）
</script>
```

而在OSX系统下，滚动条不占高度，这时候 `client` 宽度还是 200。

**总结**

 - 无 `padding` 无滚动：clientWidth = 盒子的width
 - 有 `padding` 无滚动：clientWidth = 盒子的width + 盒子的padding*2
 - 有 `padding` 有滚动条，且滚动条是显示的：clientWidth = 盒子的width + 盒子的padding*2 - 滚动轴宽度`
 
**clientLeft和clientTop**

这两个返回的是**元素周围边框的厚度**，如果不指定一个边框或者不定位该元素，他的值就是0。

我们还是以 `body` 为例：

```html
<style>
body{
    border: 20px solid #000;
    margin: 10px;
    padding: 40px;
    background: #eee;
    height: 350px;
    width: 500px;
    overflow: scroll;
}
</style>
<script>
    console.log(document.body.clientLeft); // 20
    console.log(document.body.clientTop); // 20
</script>
```

**总结**

这一对属性是用来读取元素的 `border` 的宽度和高度的

 - `clientTop = border - top`
 - `clientLeft = border - left` 

### 与offset相关宽高介绍

与 `offset` 相关的宽高又有如下几个属性：

 - `document.body.offsetWidth`
 - `document.body.offsetHeight`
 - `document.offsetLeft`
 - `document.offsetTop`
 
**offsetWidth与offsetHeight**

- `document.body.offsetWidth`（元素的 border+padding+content 的宽度）
- `document.body.offsetHeight`（元素的 border+padding+content 的高度）

该属性和其内部是否超出元素大小无关，只和本来设定的 `border` 以及 `width` 和 `height` 有关

我们还是 `body` 为例：

```html
<style>
body {
    border: 20px solid #000;
    margin: 10px;
    padding: 40px;
    background: #eee;
    height: 350px;
    width: 500px;
    overflow: scroll;
}
</style>
<script>
console.log(document.body.offsetWidth); // 620(width + margin*2 + padding*2 + border*2)
console.log(document.body.offsetHeight); // 470(width + margin*2+padding*2 + border*2)
</script>
```

**总结**

 - 无 `padding` 无滚动无 `border`
    - offsetWidth = clientWidth = 盒子宽度
 - 有 `padding` 无滚动有 `border`
    - offsetWidth = 盒子的宽度 + 盒子的padding*2 + 盒子的border*2 = clientWidth + border*2
 - 有 `padding` 有滚动，且滚动是显示的，有 `border`
    - offsetWidth = 盒子宽度 + 盒子padding*2 + 盒子的border*2 = clientWidth + 滚动轴宽度 + border*2

**offsetLeft和offsetTop**

这两个属性是基于 `offsetParent` 的，了解这两个属性我们必须先了解它，什么是 `offsetParent`呢？

 - 如果当前元素的父级元素没有进行CSS定位( `position` 为 `absolute`或`relative`)，`offsetParent` 为 `body`
 - 假如当前元素的父级元素中有CSS定位，`offsetParent`取最近的那个父级元素


 - *在IE6/7中*
   - offsetLeft === (offsetParent的padding-left)+(当前元素的margin-left)
 - *在IE8/9/10及Chrome中*
   - offsetLeft === (offsetParent的margin-left)+(offsetParent的border宽度)+(offsetParent的padding-left)+(当前元素的margin-left)
 - *在firefox中*
   - offsetLeft === (offsetParent的margin-left)+(当前元素的margin-left)+(offsetParent的padding-left)

```html
<style>
body {
    border: 20px solid #000;
    margin: 10px;
    padding: 40px;
    background: #eee;
    height: 350px;
    width: 500px;
}
#mydiv {
    width: 400px;
    height: 200px;
    padding: 20px;
    margin: 10px;
    background: #f60;
    border: 20px solid #888;
}
</style>
```

- 在IE8/910及Chrome中

```javascript
mydiv.offsetLeft === 80
mydiv.offsetTop === 80
```

 - 在firefox中

```javascript
mydiv.offsetLeft === 60
mydiv.offsetTop === 60
```

 - 在IE低版本IE6/7中是

```javascript
mydiv.offsetLeft === 50
mydiv.offsetTop === 50
```

### 与scroll相关宽高介绍

与 `scroll` 相关的宽高属性有如下几个：

 - `document.body.scrollWidth`
 - `document.body.scrollHeight`
 - `document.body.scrollLeft`
 - `document.body.scrollTop`
 
**scrollWidth和scrollHeight**

`document.body` 的 `scrollWidth` 和 `scrollHeight` 与 `div` 的 `scrollWidth` 和 `scrollHeight` 是有区别的。

我们先来看看 `document.body` 的 `scrollWidth` 和 `scrollHeight`：

1. 给定宽高小于浏览器窗口

	* `scrollWidth` 通常是浏览器窗口的宽度
	* `scrollHeight` 通常是浏览器窗口的高度

2. 给定宽高大于浏览器窗口，且内容小于给定宽高

	* `scrollWidth` 给定的宽度+其所有padding、margin和border
	* `scrollHeight` 给定的高度+其所有的padding、margin和border

3. 给定宽高大于浏览器窗口，且内容大于给定宽高

	* `scrollWidth` 内容宽度+其所有的-padding、margin和border
	* `scrollHeight` 内容高度+其所有的padding、margin和border

再来看看在某 `div` 中 `scrollWidth` 和 `scrollHeight`：

- **在无滚动轴的时候**

scrollWidth = clientWidth = 盒子宽度 + 盒子padding*2


- **在有滚动轴的时候**

```javascript
scrollWidth == 实际内容的宽度 + padding2
scrollHeight == 实际内容的高度 + padding2
```

**scrollLeft和scrollTop**

这对属性是**可读写（可被重新赋值）** 的，指的是当元素其中的内容超出其宽高的时候，元素被卷起来的高和宽度。

```
#exp {
    width: 400px;
    height: 200px;
    padding: 20px;
    margin: 10px;
    background: red;
    border: 20px solid #000;
    overflow-y: scroll;
}

var mydiv = document.getElementById('exp');
mydiv.scrollTop; // 默认情况下是0
mydiv.scrollLeft; // 默认情况下是0

// 可以改写它

mydiv.scrollTop = 20;
console.log(mydiv.scrollTop);
```

**obj.style.width和obj.style.height**

对于一个dom元素，它的style属性返回的是一个对象，这个对象中的任意一个属性是可读写的，`style.width` 等于CSS属性中的宽度 `style.height` 等于CSS属性中的高度。

## documentElement和body的关系

`documentElement`和`body`的关系是父子级的关系

```
body{
    border: 20px solid #000;
    margin: 10px;
    padding: 40px;
    background: #eee;
    height: 350px;
    width: 500px;
    overflow: scroll;
}

#exp {
    width:400px;
    height:200px;
    padding:20px;
    margin:10px;
    background:red;
    border:20px solid #000;
    overflow-y:scroll;
}

console.log(document); //document
console.log(document.documentElement); //html
console.log(document.body); //body
```

兼容问题推荐使用：获取浏览器窗口可视区域大小

```javascript
document.body.clientWidth || document.documentElement.clientWidth
document.body.clientHeight || document.documentElement.clientHeight
```

## Event对象的5种坐标

	1. `clientX` 和 `clientY`：相对于浏览器（可视区左上角0,0）的坐标
	2. `screenX`和 `screenY`：相对于设备屏幕左上角（0,0）的坐标
	3. `offsetX`和 `offsetY`：相对于事件源左上角（0,0）的坐标
	4. `pageX` 和 `pageY`：相对于整个网页左上角（0,0）的坐标
	5. `X` 和 `Y`：本来是IE属性，相对于用CSS动态定位的最内层包容元素

例：

```html
<div id='example' style='width: 200px;height: 200px;background: red;margin: 100px auto;'></div>
```

```javascript
var example = document.getElementById('example');
example.onclick = function (e){
    console.log("clientX "+e.clientX + " : " + " clientY "+e.clientY);
    console.log("screenX "+e.screenX + " : " + " screenY "+e.screenY);
    console.log("offsetX "+e.offsetX + " : " + " offsetY "+e.offsetY);
    console.log("pageX "+e.pageX + " : " + " pageY "+e.pageY);
    console.log("x "+e.x + " : " + " y "+e.y);
}
```

注意之处：`pageX`、`pageY`、`clientX`、`clientY`区别

 - 兼容性问题
   - `pageX`、`pageY`(Chrome\Firefox\IE678无效)：拿到滚动条的高度+第一屏的距离
   - `clientX`、`clientY`(IE及其他浏览器)：只会拿到第一屏的距离，不会拿到滚动条的高度
 - 在没有滚动条的情况，第一屏下
   - `clientX`、`pageX`获取的鼠标位置是一致的
   - `clientY`、`pageY`获取的鼠标位置是一致的
 
 - 在有滚动条的情况
   - `clientX`、`pageX`获取的鼠标位置有区别
   - `clientY`、`pageY`获取的鼠标位置有区别
  
 - 浏览器的滚动距离 `scrollTop`、`scrollLeft`
    - `document.body.scrollTop` // Chrome
    - `document.documentElement.scrollTop` // 其他浏览器
    - 兼容写法：`document.body.scrollTop || document.documentElement.scrollTop`
  
**封装一个函数获取鼠标距离顶部左侧的实际距离（兼容IE、FF、Chrome）**

```javascript
function getMouseLocation(e) {
    let e = e || window.event
    let xx = 0;
    let yy = 0;
    if (e.pageX){ 
        // IE9+
        xx = e.pageX;
        yy = e.pageY;
    } else {
        // IE678 clientX,clientY + scroll
        let scrollTop = document.documentElement.scrollTop || document.body.scrollTop; // IE9+
        let scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft; // IE9+
        xx = e.clientX + scrollLeft;
        yy = e.clientY + scrollTop;
    }
    
    return {
        x: xx,
        y: yy
    }
}
```

## JS各种宽高的应用

### 可视区域加载

用于解决 `offset` 的兼容性难问题

```html
<div id='example1'></div>
```

```css
#example1 {
    width: 500px;
    height: 350px;
    background: red;
    margin: 1000px auto 0 auto;
}
@-webkit-keyframes fadeInLeft{
    0%{
        opacity: 0;
        transform: translate3d(-100%,0,0);
    }
    100%{
        opacity: 1;
        transform: none;
    }
}
.fadeInLeft {
    animation-name: fadeInLeft;
    animation-duration: 2s;
}
```

```javascript
function showDiv (){
    let example = document.getElementById('example1');
    let clients = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight; // 可视区域的高度
    let divTop = example.getBoundingClientRect().top;
    if(divTop <= clients){
        example.classList.add("fadeInLeft");
        // 这里可以通过setAttribute设置图片的src按需加载
    }
    document.title = clients+"---"+divTop;
}

window.onscroll = showDiv;
```

### 元素滚到底部加载

```html
<div id="example2" >
DIV滚动到底部加载...(省略若干)
</div>
```

```css
#example2 {
    width: 500px;
    height: 400px;
    background: red;
    margin: 10px auto;
    padding: 10px;
    overflow-y: scroll;
}
```

```javascript
let div = document.getElementById('example2');
function divScroll(){
    let wholeHeight = div.scrollHeight; // 滚动区域高度
    let divScrollTop = div.scrollTop; // 卷上去的那部分高度
    let divHeight = div.clientHeight; // div的可视区域的高度
    
    if (divScrollTop + divHeight >= wholeHeight) {
        alert('我已经到了底部！');
        // 这里可以在div中通过滚动加载分页按需显示
    } else if (divScrollTop == 0) {
        alert('我已经到了顶部了！');
    }
    document.title = (divScrollTop + divHeight) + '---' + wholeHeight + '---' + divScrollTop;
}

div.onscroll = divScroll;
```

### 计算滚动轴的宽度

```javascript
// 获取滚动轴的宽度
function getScrollBar(){
    let el = document.createElement("p");
    let styles = {
        width:"100px",
        height:"100px",
        overflowY:"scroll"
    };
    for (var prop in styles){
        el.style[prop] = styles[prop];//把 styles上的属性全部遍历拷贝到el.style上
    }
    document.body.appendChild(el);
    let scrollBarWidth = el.offsetWidth - el.clientWidth;
    el.remove();
        return scrollBarWidth;
    }
    alert(getScrollBar());//17
```

## JS中的宽高属性总结

属性  |  描述
:---: | :---:
`offsetParent` | 偏移的父容器
`getBoundingClientRect()` | 获取页面元素实际位置和宽高（返回属性对象）
`offsetWidth` | 元素宽度（可视内容区+滚动条+内边距+边框）
`offsetHeight` | 元素高度（可视内容区+滚动条+内边距+边框）
`offsetLeft` | 与相邻父级的左距离
`offsetTop` | 与相邻父级的上距离
`clientWidth` | 元素宽度（可视内容区+内边距）
`clientHeight` | 元素高度（可视内容区+内边距）
`clientLeft` | 内边距边缘与边框边缘的距离（左边框）
`clientTop` | 内边距边缘与边框边缘的距离（上边框）
`scrollWidth` | 元素宽度（可视内容区+滚动内容区+内边距）
`scrollHeight` | 元素高度（可视内容区+滚动内容区+内边距）
`scrollLeft` | 隐藏的滚动宽度（待滚动宽度）
`scrollTop` | 隐藏的滚动高度（待滚动宽度）
兼容性 | `clientWidth`/`clientHeight`和`scrollWidth`/`scrollHeight`存在浏览器差异

