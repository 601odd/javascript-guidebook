# 定时器

## window.setTimeout()

`setTimeout()` 方法用于在指定的毫秒数后调用函数或计算表达式。。

**语法**

> `let timeoutID = setTimeout(function, [milliseconds, param1, param2, ...]);`
`let timeoutID = setTimeout(function[, milliseconds]);`
`let timeoutID = setTimeout(code[,milliseconds]);`

**参数**

- **`function`**

`function` 是你想要在 `milliseconds` 毫秒之后执行的函数

- **`code`**

这是一个替代语法，你可以使用字符串代替 `function` ，在 `milliseconds` 毫秒之后执行字符串 (使用该语法是不推荐的, 原因和使用 `eval()` 一样，有安全风险)。

- **`milliseconds`**

延迟的毫秒数 (一秒等于1000毫秒)，函数的调用会在该延迟之后发生。如果省略该参数，delay取默认值0。实际的延迟时间可能会比 delay 值长，原因请查看 [Reasons for delays longer than][1] specified。

- **`args`**

附加参数，一旦定时器到期，它们会作为参数传递给 `function` 或 执行字符串（setTimeout参数中的code）

**返回值**

返回值 `timeoutID` 是一个正整数，表示定时器的编号。这个值可以传递给 `clearTimeout()` 函数来取消该定时。

需要注意的是 `setTimeout()` 和 `setInterval()` 共用一个编号池，技术上，`clearTimeout()` 和 `clearInterval()` 可以互换。但是，为了避免混淆，不要混用取消定时函数。

在同一个对象上（一个window或者worker），setTimeout()或者setInterval()返回的定时器编号不会重复。但是不同的对象使用独立的编号池。

## window.setInterval()

`setInterval()` 方法重复调用一个函数或执行一个代码段，在每次调用之间具有固定的时间延迟。

**语法**

> `let intervalID = window.setInterval(func, delay[, param1, param2, ...]);`
`let intervalID = window.setInterval(code, delay);`

**参数**

 - **`intervalID`** 是此重复操作的唯一辨识符，可以作为参数传给 `clearInterval()`。
 - **`func`** 是你想要重复调用的函数。
 - **`code`** 是另一种语法的应用，是指你想要重复执行的一段字符串构成的代码(使用该语法是不推荐的，不推荐的原因和eval()一样)。
 - **`delay`** 是每次延迟的毫秒数 (一秒等于1000毫秒)，函数的每次调用会在该延迟之后发生。和setTimeout一样，实际的延迟时间可能会稍长一点。

需要注意的是,IE不支持第一种语法中向延迟函数传递额外参数的功能.如果你想要在IE中达到同样的功能,你必须使用一种兼容代码 (查看callback arguments 一段).

**HTML5标准规定，setTimeout的最短时间间隔是4毫秒；setInterval的最短间隔时间是10毫秒，也就是说，小于10毫秒的时间间隔会被调整到10毫秒**

## 运行机制

```javascript
let date = new Date();
// 打印进入时的时间
console.log('First time:' + data.getTime());
// 一秒后打印setTimeout里匿名函数的时间
setTimeout(function(){
    var date1 = new Date();
    console.log('Second time:' + date1.getTime());
    console.log(date1.getTime() - date.getTime());
}, 1000);
// 重复操作
for(var i = 0;i < 10000; i++){
    console.log(1);
}
```

输出结果

![定时器测试结果][2]

```javascript
// 一秒后执行setTimeout里的匿名函数,alert下
setTimeout(function(){
    alert("monkey");
},1000);
while(true){};
```

JavaScript引擎是单线程运行的，浏览器无论在什么时候都只且只有一个线程在运行JavaScript程序（s因此 `setTimeout`没有实现多线程）

浏览器的内核是多线程的，它们在内核控制下相互配合以保持同步，一个浏览器至少实现三个常驻线程：**JavaScript引擎线程**，**GUI渲染线程**，**浏览器事件触发线程**。

***JavaScript引擎**，是基于事件驱动单线程执行的，JavaScript引擎一直等待着任务队列中任务的到来，然后加以处理，浏览器无论什么时候都只有一个JavaScript线程在运行JavaScript程序。

***GUI渲染线程**，负责渲染浏览器界面，当界面需要重绘（Repaint）或由于某种操作引发回流(Reflow)时,该线程就会执行。但需要注意，GUI渲染线程与JavaScript引擎是互斥的，当JavaScript引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JavaScript引擎空闲时立即被执行。

***事件触发线程**，当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JavaScript引擎的处理。这些事件可来自JavaScript引擎当前执行的代码块如setTimeout、也可来自浏览器内核的其他线程如鼠标点击、Ajax异步请求等，但由于JavaScript的单线程关系所有这些事件都得排队等待JavaScript引擎处理（当线程中没有执行任何同步代码的前提下才会执行异步代码）。


  [1]: https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout#Reasons_for_delays_longer_than_specified
  [2]: https://images2015.cnblogs.com/blog/887360/201604/887360-20160401214058488-1797966800.png